<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AetherBound 2D Sandbox (Robust Collision Fix)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a2e; /* Deep purple background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }
        #game-container {
            width: 100%;
            max-width: 900px; /* Max width constraint */
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            background-color: #2c0f4f; /* Slightly lighter purple for container */
        }
        #game-canvas {
            /* This ensures the canvas respects its fixed internal size but scales visually */
            display: block; 
            width: 100%; /* Make it fill the container's max-width */
            height: auto;
            background-color: #87ceeb; /* Sky blue */
            border-bottom: 4px solid #38bdf8;
            cursor: crosshair;
        }
        #ui-panel {
            padding: 12px 20px;
            background-color: #2c0f4f;
            color: #ffffff;
            border-top: 2px solid #38bdf8;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #inventory-bar {
            display: flex;
            gap: 8px;
        }
        .inv-slot {
            width: 48px;
            height: 48px;
            background-color: #4a148c;
            border: 2px solid #5d209d;
            border-radius: 6px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.1s ease;
            position: relative;
        }
        .inv-slot.selected {
            border-color: #fca311;
            box-shadow: 0 0 10px #fca311;
            transform: scale(1.05);
        }
        .item-count {
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 1px 3px;
            border-radius: 3px;
        }
        .tile-color-1 { background-color: #7b3f00; } /* Dirt */
        .tile-color-2 { background-color: #468e27; } /* Grass */
        .tile-color-3 { background-color: #808080; } /* Stone */
        .tile-color-4 { background-color: #333333; } /* Coal Ore */
    </style>
    <!-- Firebase Imports -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        window.firebase = {
            initializeApp, getAuth, signInAnonymously, signInWithCustomToken, getFirestore, doc, setDoc, getDoc
        };
    </script>
</head>
<body>

<div id="game-container">
    <canvas id="game-canvas"></canvas>
    <div id="ui-panel">
        <div id="status-message" class="text-sm font-semibold text-sky-400">Loading Game...</div>
        <div id="inventory-bar">
            <!-- Inventory slots generated by JS -->
        </div>
    </div>
</div>

<script type="module">
    // --- Global Variables (Provided by Canvas Environment) ---
    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
    const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
    // FIX: Accessing __initial_auth_token directly instead of the uninitialized const
    const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null; 

    // --- Game Constants ---
    const TILE_SIZE = 32;
    const WORLD_WIDTH_TILES = 40;
    const WORLD_HEIGHT_TILES = 25;
    const GRAVITY = 1;
    const MAX_REACH_DISTANCE = 4; // Max tiles away player can interact

    // --- Firebase Initialization ---
    let db, auth;
    let userId = null;
    let isAuthReady = false;
    const worldPath = (uid) => `artifacts/${appId}/users/${uid}/game_worlds/main_world`;

    async function initializeFirebase() {
        try {
            if (firebaseConfig) {
                const app = firebase.initializeApp(firebaseConfig);
                db = firebase.getFirestore(app);
                auth = firebase.getAuth(app);

                if (initialAuthToken) {
                    await firebase.signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await firebase.signInAnonymously(auth);
                }
                
                userId = auth.currentUser.uid;
                isAuthReady = true;
                console.log("Firebase initialized. User ID:", userId);
                document.getElementById('status-message').textContent = `User: ${userId.substring(0, 8)}...`;
            } else {
                isAuthReady = true;
                console.warn("Firebase config missing. Running in offline mode.");
                document.getElementById('status-message').textContent = 'Offline Mode';
            }
        } catch (error) {
            console.error("Firebase Initialization Error:", error);
            isAuthReady = true; 
            document.getElementById('status-message').textContent = 'Auth Error';
        }
    }

    // --- Game State ---
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    
    // Set canvas dimensions explicitly for fixed coordinate system (1280x800)
    canvas.width = WORLD_WIDTH_TILES * TILE_SIZE;
    canvas.height = WORLD_HEIGHT_TILES * TILE_SIZE;

    const TILE_TYPES = {
        0: { name: "Air", color: "transparent", minable: false, inventory_item: false },
        1: { name: "Dirt", color: "#7b3f00", minable: true, drops: 1, inventory_item: false },
        2: { name: "Grass", color: "#468e27", minable: true, drops: 1, inventory_item: false },
        3: { name: "Stone", color: "#808080", minable: true, drops: 3, inventory_item: false },
        4: { name: "Coal Ore", color: "#333333", minable: true, drops: 4, inventory_item: false },
    };
    
    const player = {
        x: canvas.width / 2,
        y: 0, 
        w: TILE_SIZE * 0.8,
        h: TILE_SIZE * 1.5,
        velX: 0,
        velY: 0,
        speed: 5,
        jumpPower: 15,
        onGround: false,
        miningTimer: 0,
        miningBlock: null,
        reach: TILE_SIZE * MAX_REACH_DISTANCE,
        inventory: {
            1: 99, // Dirt
            3: 50, // Stone
            4: 20, // Coal
        },
        selectedSlot: 1 
    };

    let worldMap = [];
    let keys = {};
    let mouse = { x: 0, y: 0, leftDown: false, rightDown: false }; 

    // --- World Generation and Data Management ---

    function generateNewWorld() {
        console.log("Generating a varied world...");
        const newMap = [];
        const baseSurfaceLevel = Math.floor(WORLD_HEIGHT_TILES * 0.4); 

        // Pre-calculate surface height variation using a simple sine function
        const heightMap = [];
        for (let x = 0; x < WORLD_WIDTH_TILES; x++) {
            const sineHeight = Math.sin(x * 0.2 + 5) * 2; 
            const noise = (Math.random() * 2) - 1; 
            heightMap[x] = baseSurfaceLevel + Math.round(sineHeight + noise);
        }

        for (let y = 0; y < WORLD_HEIGHT_TILES; y++) {
            newMap[y] = [];
            for (let x = 0; x < WORLD_WIDTH_TILES; x++) {
                const surfaceLevel = heightMap[x];
                let blockId = 0;

                if (y < surfaceLevel) {
                    blockId = 0; // Air
                } else if (y === surfaceLevel) {
                    blockId = 2; // Grass
                } else if (y > surfaceLevel && y < surfaceLevel + 4) {
                    blockId = 1; // Shallow Dirt
                } else {
                    // Underground layers
                    const depth = y - (surfaceLevel + 4); 
                    
                    if (depth < 6) { 
                        blockId = (Math.random() < 0.25) ? 3 : 1; // 25% chance of stone
                    } else { 
                        if (Math.random() < 0.7) {
                            blockId = 3; // Stone
                        } else {
                            blockId = (Math.random() < 0.33) ? 4 : 3; 
                        }
                    }
                }

                newMap[y][x] = blockId;
            }
        }
        worldMap = newMap;
        
        // Find a safe spawn point 
        const spawnX = Math.floor(WORLD_WIDTH_TILES / 2);
        const spawnY = heightMap[spawnX] - 2; 
        
        player.x = spawnX * TILE_SIZE + (TILE_SIZE - player.w) / 2;
        player.y = spawnY * TILE_SIZE;
        
        // Ensure player spawn area is clear
        newMap[Math.floor(player.y/TILE_SIZE)][Math.floor(player.x/TILE_SIZE)] = 0;
        newMap[Math.floor(player.y/TILE_SIZE) + 1][Math.floor(player.x/TILE_SIZE)] = 0;
    }

    async function loadWorld() {
        if (!isAuthReady) {
            generateNewWorld();
            return;
        }
        
        try {
            const docRef = firebase.doc(db, worldPath(userId));
            const docSnap = await firebase.getDoc(docRef);

            if (docSnap.exists() && docSnap.data().mapData) {
                const data = docSnap.data();
                worldMap = JSON.parse(data.mapData); 
                player.x = data.playerX || player.x;
                player.y = data.playerY || player.y;
                player.inventory = data.inventory || player.inventory;
                player.selectedSlot = data.selectedSlot || player.selectedSlot;
                console.log("World loaded successfully.");
            } else {
                console.log("No world found, generating new one.");
                generateNewWorld();
            }
        } catch (error) {
            console.error("Error loading world:", error);
            generateNewWorld(); // Fallback
        }
    }
    
    async function saveWorld() {
        if (!isAuthReady || !userId) return;

        try {
            const docRef = firebase.doc(db, worldPath(userId));
            const mapDataString = JSON.stringify(worldMap);

            await firebase.setDoc(docRef, {
                mapData: mapDataString,
                playerX: player.x,
                playerY: player.y,
                inventory: player.inventory,
                selectedSlot: player.selectedSlot,
                timestamp: Date.now()
            });
            console.log("World saved successfully!");
        } catch (error) {
            console.error("Error saving world:", error);
        }
    }


    // --- Physics and Player Logic (NEW ROBUST COLLISION) ---

    function isTileSolid(tileX, tileY) {
        if (tileX >= 0 && tileX < WORLD_WIDTH_TILES && tileY >= 0 && tileY < WORLD_HEIGHT_TILES) {
            // Check if the tile exists and is not 'Air' (ID 0)
            return worldMap[tileY][tileX] > 0;
        }
        // Blocks outside the map are considered not solid (allows player to fall if out of bounds)
        return false; 
    }

    // Checks if the given AABB (x, y, w, h) overlaps with any solid tile.
    // Returns the {x, y} coordinates of the first colliding tile, or false if no collision.
    function checkCollision(x, y, w, h) {
        // Calculate the range of tiles the player's bounding box covers
        const startX = Math.floor(x / TILE_SIZE);
        const endX = Math.ceil((x + w) / TILE_SIZE) - 1;
        const startY = Math.floor(y / TILE_SIZE);
        const endY = Math.ceil((y + h) / TILE_SIZE) - 1;

        // Iterate through all potential overlapping tiles
        for (let tileY = startY; tileY <= endY; tileY++) {
            for (let tileX = startX; tileX <= endX; tileX++) {
                if (isTileSolid(tileX, tileY)) {
                    // Collision found. Return the tile's grid coordinates.
                    return { x: tileX, y: tileY };
                }
            }
        }
        return false;
    }
    
    // Helper function: Checks if the player is currently standing on a solid tile (1 pixel nudge down)
    function isPlayerOnGroundCheck() {
        return !!checkCollision(player.x, player.y + 1, player.w, player.h);
    }

    function updatePlayer() {
        // Apply damping when keys are not pressed
        if (!keys['a'] && !keys['d']) {
            player.velX *= 0.8;
            if (Math.abs(player.velX) < 0.5) player.velX = 0;
        }

        if (keys['a']) player.velX = -player.speed;
        if (keys['d']) player.velX = player.speed;
        
        player.velX = Math.min(Math.max(player.velX, -player.speed * 2), player.speed * 2);
        
        // Check for jump eligibility using a check 1 pixel below the player (fixes mid-air jump issue)
        const canJump = isPlayerOnGroundCheck(); 
        
        // 1. X-AXIS MOVEMENT AND COLLISION RESOLUTION
        player.x += player.velX;
        let collisionX = checkCollision(player.x, player.y, player.w, player.h);

        if (collisionX) {
            const tileX = collisionX.x;
            
            if (player.velX > 0) { // Moving Right, collide with tile's left edge
                // Snap player to the left edge of the colliding tile
                player.x = tileX * TILE_SIZE - player.w - 0.1; 
            } else if (player.velX < 0) { // Moving Left, collide with tile's right edge
                // Snap player to the right edge of the colliding tile
                player.x = (tileX + 1) * TILE_SIZE + 0.1;
            }
            player.velX = 0;
        }

        // 2. Y-AXIS MOVEMENT AND COLLISION RESOLUTION (Gravity & Jump)
        player.velY += GRAVITY;
        player.velY = Math.min(player.velY, TILE_SIZE * 2); // Clamp max fall speed
        
        // Jump check (using the calculated canJump status)
        if (keys[' '] && canJump) {
            player.velY = -player.jumpPower;
        }
        
        // Reset onGround status if we have upward or downward velocity,
        // it will be correctly set to true only on the landing collision.
        if (player.velY !== 0) {
            player.onGround = false; 
        }

        player.y += player.velY;
        let collisionY = checkCollision(player.x, player.y, player.w, player.h);

        if (collisionY) {
            const tileY = collisionY.y;
            
            if (player.velY > 0) { // Moving Down (Landing)
                // Snap player to the top of the colliding tile
                player.y = tileY * TILE_SIZE - player.h - 0.1; 
                player.onGround = true; // This is the only place we set to true
                player.velY = 0;
            } else if (player.velY < 0) { // Moving Up (Hitting Head)
                // Snap player to the bottom of the colliding tile
                player.y = (tileY + 1) * TILE_SIZE + 0.1;
                player.velY = 0;
            }
        }
        
        // Clamp player within world bounds
        player.x = Math.max(0, Math.min(player.x, canvas.width - player.w));
        player.y = Math.max(0, Math.min(player.y, canvas.height - player.h));
    }
    
    // --- Interaction Logic (Unchanged) ---

    function getMouseTile() {
        const tileX = Math.floor(mouse.x / TILE_SIZE);
        const tileY = Math.floor(mouse.y / TILE_SIZE);
        return { x: tileX, y: tileY };
    }
    
    function isMouseWithinReach(tileX, tileY) {
        const playerCenterTileX = Math.floor((player.x + player.w / 2) / TILE_SIZE);
        const playerCenterTileY = Math.floor((player.y + player.h / 2) / TILE_SIZE);

        const dx = Math.abs(tileX - playerCenterTileX);
        const dy = Math.abs(tileY - playerCenterTileY);
        
        return dx <= MAX_REACH_DISTANCE && dy <= MAX_REACH_DISTANCE;
    }

    function handleMining(tileX, tileY) {
        if (!isMouseWithinReach(tileX, tileY)) {
            player.miningBlock = null;
            player.miningTimer = 0;
            return;
        }

        if (tileY < 0 || tileY >= WORLD_HEIGHT_TILES || tileX < 0 || tileX >= WORLD_WIDTH_TILES) return;

        const blockId = worldMap[tileY][tileX];
        if (blockId > 0 && TILE_TYPES[blockId].minable) {
            
            if (!player.miningBlock || player.miningBlock.x !== tileX || player.miningBlock.y !== tileY) {
                player.miningBlock = { x: tileX, y: tileY, id: blockId };
                player.miningTimer = 0;
            }
            
            player.miningTimer += 1;
            
            const miningTime = 60; 
            
            if (player.miningTimer >= miningTime) {
                const dropId = TILE_TYPES[blockId].drops;
                worldMap[tileY][tileX] = 0; 
                player.inventory[dropId] = (player.inventory[dropId] || 0) + 1;
                
                player.miningBlock = null;
                player.miningTimer = 0;
                
                updateInventoryUI();
                saveWorld();
            }
        } else {
            player.miningBlock = null;
            player.miningTimer = 0;
        }
    }
    
    function handlePlacement(tileX, tileY) {
        if (!isMouseWithinReach(tileX, tileY)) return;
        if (tileY < 0 || tileY >= WORLD_HEIGHT_TILES || tileX < 0 || tileX >= WORLD_WIDTH_TILES) return;


        const currentBlock = worldMap[tileY][tileX];
        const itemToPlace = player.selectedSlot;
        
        if (currentBlock !== 0) return;
        
        // This check is now redundant due to robust collision, but kept as an extra safety measure
        // to prevent placing a block right on the player's position.
        if (checkCollision(tileX * TILE_SIZE, tileY * TILE_SIZE, TILE_SIZE, TILE_SIZE)) return;

        if (player.inventory[itemToPlace] > 0 && TILE_TYPES[itemToPlace].inventory_item === false) {
            worldMap[tileY][tileX] = itemToPlace;
            player.inventory[itemToPlace] -= 1;
            
            if (player.inventory[itemToPlace] <= 0) {
                delete player.inventory[itemToPlace];
                const items = Object.keys(player.inventory).map(Number).sort((a, b) => a - b);
                player.selectedSlot = items.length > 0 ? items[0] : 0;
            }
            
            updateInventoryUI();
            saveWorld();
        }
    }

    // --- Rendering (Unchanged) ---

    function drawWorld() {
        for (let y = 0; y < WORLD_HEIGHT_TILES; y++) {
            for (let x = 0; x < WORLD_WIDTH_TILES; x++) {
                const blockId = worldMap[y][x];
                if (blockId > 0) {
                    const type = TILE_TYPES[blockId];
                    ctx.fillStyle = type.color;
                    
                    ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
                    ctx.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    
                    if (blockId === 2) {
                        ctx.fillStyle = TILE_TYPES[1].color; 
                        ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE + TILE_SIZE / 4, TILE_SIZE, TILE_SIZE * 3 / 4);
                        ctx.fillStyle = TILE_TYPES[2].color; 
                        ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE / 4);
                    }
                }
            }
        }
    }

    function drawPlayer() {
        ctx.fillStyle = '#fca311'; 
        ctx.fillRect(player.x, player.y, player.w, player.h);
        
        ctx.fillStyle = 'black';
        const eyeX = player.x + (player.velX < 0 ? 2 : (player.velX > 0 ? player.w - 5 : player.w / 2 - 2));
        ctx.fillRect(eyeX, player.y + 5, 4, 4);
    }
    
    function drawMiningProgress() {
        if (player.miningBlock) {
            const { x, y } = player.miningBlock;
            const miningTime = 60;
            const progress = player.miningTimer / miningTime;
            
            if (progress > 0) {
                const drawX = x * TILE_SIZE;
                const drawY = y * TILE_SIZE;
                
                ctx.strokeStyle = `rgba(255, 255, 255, ${Math.min(1, progress * 2)})`;
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(drawX + TILE_SIZE/2, drawY + TILE_SIZE/2, (TILE_SIZE / 2) * progress, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                ctx.fillRect(drawX, drawY + TILE_SIZE - 5, TILE_SIZE * progress, 5);
            }
        }
    }
    
    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height); 
        ctx.fillStyle = '#87ceeb';
        ctx.fillRect(0, 0, canvas.width, canvas.height); 

        drawWorld();
        drawMiningProgress();
        drawPlayer();
        
        // Highlight the currently targeted tile
        const { x: tileX, y: tileY } = getMouseTile();
        if (isMouseWithinReach(tileX, tileY)) {
            ctx.strokeStyle = mouse.leftDown || mouse.rightDown ? 'red' : 'yellow'; 
            ctx.lineWidth = 3;
            ctx.strokeRect(tileX * TILE_SIZE, tileY * TILE_SIZE, TILE_SIZE, TILE_SIZE);
        }
    }

    // --- UI Update (Unchanged) ---

    function updateInventoryUI() {
        const bar = document.getElementById('inventory-bar');
        bar.innerHTML = '';
        
        const itemIds = Object.keys(player.inventory).map(Number).sort((a, b) => a - b);
        
        itemIds.forEach((id, index) => {
            const slot = document.createElement('div');
            const itemName = TILE_TYPES[id].name.substring(0, 1);
            const count = player.inventory[id];
            
            slot.className = `inv-slot ${player.selectedSlot === id ? 'selected' : ''}`;
            slot.classList.add(`tile-color-${id}`);
            slot.textContent = itemName;
            slot.setAttribute('data-item-id', id);
            
            const countSpan = document.createElement('span');
            countSpan.className = 'item-count';
            countSpan.textContent = count;
            slot.appendChild(countSpan);
            
            slot.onclick = () => {
                player.selectedSlot = id;
                updateInventoryUI();
            };
            
            bar.appendChild(slot);
        });
        
        if (itemIds.length < 5) {
            for (let i = itemIds.length; i < 5; i++) {
                const slot = document.createElement('div');
                slot.className = 'inv-slot opacity-50';
                slot.textContent = '';
                bar.appendChild(slot);
            }
        }
    }
    
    // --- Event Listeners (Unchanged) ---

    function handleKeyDown(e) {
        if (['a', 'd', ' '].includes(e.key.toLowerCase())) {
            e.preventDefault();
        }
        
        keys[e.key.toLowerCase()] = true;
        
        const slotNumber = parseInt(e.key);
        if (slotNumber >= 1 && slotNumber <= Object.keys(player.inventory).length) {
            const itemIds = Object.keys(player.inventory).map(Number).sort((a, b) => a - b);
            if (itemIds.length > slotNumber - 1) {
                 player.selectedSlot = itemIds[slotNumber - 1];
                 updateInventoryUI();
            }
        }
    }

    function handleKeyUp(e) {
        keys[e.key.toLowerCase()] = false;
    }
    
    function handleMouseDown(e) {
        // Recalculate mouse position on click to ensure accuracy
        handleMouseMove(e); 
        
        const { x: tileX, y: tileY } = getMouseTile();

        if (e.button === 0) { // Left Click (Mine)
            mouse.leftDown = true;
        } else if (e.button === 2) { // Right Click (Place)
            mouse.rightDown = true;
            handlePlacement(tileX, tileY);
        }
        
        e.preventDefault(); 
    }

    function handleMouseUp(e) {
        if (e.button === 0) {
            mouse.leftDown = false;
        } else if (e.button === 2) {
            mouse.rightDown = false;
        }
        player.miningBlock = null;
        player.miningTimer = 0;
    }

    function handleMouseMove(e) {
        // Get the actual visual size of the canvas element
        const rect = canvas.getBoundingClientRect();
        
        // Calculate the scale factor (internal resolution / visual resolution)
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;

        // Apply the scale factor to the mouse coordinates (e.offsetX/Y are relative to the visual size)
        mouse.x = e.offsetX * scaleX;
        mouse.y = e.offsetY * scaleY;
    }

    canvas.addEventListener('mousemove', handleMouseMove);
    canvas.addEventListener('mousedown', handleMouseDown);
    canvas.addEventListener('mouseup', handleMouseUp);
    document.addEventListener('keydown', handleKeyDown);
    document.addEventListener('keyup', handleKeyUp);
    canvas.addEventListener('contextmenu', e => e.preventDefault()); 

    let lastSave = Date.now();
    const saveInterval = 30000; 

    // --- Game Loop ---
    function gameLoop() {
        updatePlayer();
        
        if (mouse.leftDown) { 
            const { x: tileX, y: tileY } = getMouseTile();
            handleMining(tileX, tileY); 
        }

        draw();
        
        if (Date.now() - lastSave > saveInterval) {
            saveWorld();
            lastSave = Date.now();
        }

        requestAnimationFrame(gameLoop);
    }
    
    // --- Startup ---
    async function initGame() {
        await initializeFirebase();
        await loadWorld();

        // Ensure player is positioned correctly after world loading/generation
        // If player.y is still 0 (default), reset it based on the generated terrain
        if (player.y === 0) {
             const surfaceLevel = Math.floor(WORLD_HEIGHT_TILES * 0.6);
             player.x = canvas.width / 2 - player.w / 2;
             player.y = (surfaceLevel - 2) * TILE_SIZE;
        }

        updateInventoryUI();
        console.log("AetherBound Initialized. Use A/D to move, SPACE to jump, Left Click to Mine, Right Click to Place.");
        gameLoop();
    }

    window.onload = initGame;
</script>

</body>
</html>
