<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AetherBound 2D Sandbox (Caves & Optimized Rendering)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a2e; /* Deep purple background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }
        #game-container {
            width: 100%;
            max-width: 1200px; /* Increased Max width constraint for visual size */
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            background-color: #2c0f4f; /* Slightly lighter purple for container */
        }
        #game-canvas {
            /* This ensures the canvas respects its fixed internal size but scales visually */
            display: block; 
            width: 100%; /* Make it fill the container's max-width */
            height: auto;
            background-color: #87ceeb; /* Sky blue */
            border-bottom: 4px solid #38bdf8;
            cursor: crosshair;
            /* Canvas size is now fixed by script based on viewport, not world size */
        }
        #ui-panel {
            padding: 12px 20px;
            background-color: #2c0f4f;
            color: #ffffff;
            border-top: 2px solid #38bdf8;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #inventory-bar {
            display: flex;
            gap: 12px;
        }
        .inv-slot {
            width: 64px; /* INCREASED */
            height: 64px; /* INCREASED */
            background-color: #4a148c;
            border: 2px solid #5d209d;
            border-radius: 6px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 16px; /* INCREASED */
            cursor: pointer;
            transition: all 0.1s ease;
            position: relative;
        }
        .inv-slot.selected {
            border-color: #fca311;
            box-shadow: 0 0 10px #fca311;
            transform: scale(1.05);
        }
        .item-count {
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 12px; /* INCREASED */
            background: rgba(0, 0, 0, 0.7);
            padding: 1px 3px;
            border-radius: 3px;
        }
        /* Tile Color Definitions (Visual for Inventory) */
        .tile-color-1 { background-color: #7b3f00; } /* Dirt */
        .tile-color-2 { background-color: #468e27; } /* Grass */
        .tile-color-3 { background-color: #808080; } /* Stone */
        .tile-color-4 { background-color: #333333; } /* Coal Ore */
    </style>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        window.firebase = {
            initializeApp, getAuth, signInAnonymously, signInWithCustomToken, getFirestore, doc, setDoc, getDoc
        };
    </script>
</head>
<body>

<div id="game-container">
    <canvas id="game-canvas"></canvas>
    <div id="ui-panel">
        <div id="status-message" class="text-sm font-semibold text-sky-400">Loading Game...</div>
        <div id="inventory-bar">
            </div>
    </div>
</div>

<script type="module">
    // --- Global Variables (Provided by Canvas Environment) ---
    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
    const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
    const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null; 

    // --- Game Constants ---
    const TILE_SIZE = 48; 
    const WORLD_WIDTH_TILES = 100; 
    const WORLD_HEIGHT_TILES = 60; 
    const GRAVITY = 1;
    const MAX_REACH_DISTANCE = 4; 
    
    // --- VIEWPORT CONSTANTS ---
    const VIEWPORT_WIDTH_TILES = 25; // How many tiles wide the screen is
    const VIEWPORT_HEIGHT_TILES = 15; // How many tiles high the screen is

    // --- World Generation Variables ---
    let WORLD_SEED = 0; // Seed for deterministic generation

    // --- Firebase Initialization ---
    let db, auth;
    let userId = null;
    let isAuthReady = false;
    const worldPath = (uid) => `artifacts/${appId}/users/${uid}/game_worlds/main_world`;

    async function initializeFirebase() {
        try {
            if (firebaseConfig) {
                const app = firebase.initializeApp(firebaseConfig);
                db = firebase.getFirestore(app);
                auth = firebase.getAuth(app);

                if (initialAuthToken) {
                    await firebase.signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await firebase.signInAnonymously(auth);
                }
                
                userId = auth.currentUser.uid;
                isAuthReady = true;
                console.log("Firebase initialized. User ID:", userId);
                document.getElementById('status-message').textContent = `User: ${userId.substring(0, 8)}...`;
            } else {
                isAuthReady = true;
                console.warn("Firebase config missing. Running in offline mode.");
                document.getElementById('status-message').textContent = 'Offline Mode';
            }
        } catch (error) {
            console.error("Firebase Initialization Error:", error);
            isAuthReady = true; 
            document.getElementById('status-message').textContent = 'Auth Error';
        }
    }

    // --- Game State ---
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    
    // Canvas size is based on viewport
    canvas.width = VIEWPORT_WIDTH_TILES * TILE_SIZE;
    canvas.height = VIEWPORT_HEIGHT_TILES * TILE_SIZE;

    const TILE_TYPES = {
        0: { name: "Air", color: "transparent", minable: false, inventory_item: false },
        1: { name: "Dirt", color: "#7b3f00", minable: true, drops: 1, inventory_item: false },
        2: { name: "Grass", color: "#468e27", minable: true, drops: 1, inventory_item: false },
        3: { name: "Stone", color: "#808080", minable: true, drops: 3, inventory_item: false },
        4: { name: "Coal Ore", color: "#333333", minable: true, drops: 4, inventory_item: false },
    };
    
    const player = {
        x: canvas.width / 2, 
        y: 0, 
        w: TILE_SIZE * 0.75, 
        h: TILE_SIZE * 1.5,
        velX: 0,
        velY: 0,
        speed: 5,
        jumpPower: 18, 
        onGround: false,
        miningTimer: 0,
        miningBlock: null,
        reach: TILE_SIZE * MAX_REACH_DISTANCE,
        inventory: {
            1: 99, // Dirt
            3: 50, // Stone
            4: 20, // Coal
        },
        selectedSlot: 1 
    };
    
    // --- Camera/Viewport State ---
    let camera = {
        offsetX: 0,
        offsetY: 0
    };


    let worldMap = [];
    let keys = {};
    let mouse = { x: 0, y: 0, leftDown: false, rightDown: false }; 

    // --- World Generation and Data Management ---

    /**
     * A simple, fast pseudo-random number generator (PRNG) based on a seed.
     * Returns a float between 0 (inclusive) and 1 (exclusive).
     */
    function seededRandom(seed, index) {
        let x = (seed * 9301 + 49297) * (index + 1) % 233280;
        return x / 233280;
    }

    // --- 1D Noise Functions (For Surface and Cave Depth) ---

    /**
     * Calculates surface height using multiple noise octaves (sine functions).
     */
    function getHeightValue(x) {
        // Deterministically generate noise parameters based on the WORLD_SEED
        const r1 = seededRandom(WORLD_SEED, 1);
        const frequency1 = 0.005 + (r1 * 0.015);
        const amplitude1 = 10 + (r1 * 10);    

        const r2 = seededRandom(WORLD_SEED, 2);
        const frequency2 = 0.03 + (r2 * 0.07); 
        const amplitude2 = 5 + (r2 * 8);      

        const r3 = seededRandom(WORLD_SEED, 3);
        const frequency3 = 0.1 + (r3 * 0.2);   
        const amplitude3 = 1 + (r3 * 4);      
        
        const noise1 = Math.sin(x * frequency1) * amplitude1;
        const noise2 = Math.sin(x * frequency2) * amplitude2;
        const noise3 = Math.sin(x * frequency3) * amplitude3;

        // Randomized component for small, chaotic variance (non-deterministic)
        const randomComponent = (Math.random() - 0.5) * 2; 

        return noise1 + noise2 + noise3 + randomComponent;
    }
    
    /**
     * Uses 1D noise to calculate the depth (Y-coordinate) where the main cave system starts (The Cave Entry).
     */
    function getCaveEntryY(x, surfaceY) {
        // Deterministically generate noise parameters based on the WORLD_SEED
        const r1 = seededRandom(WORLD_SEED, 10);
        const frequency1 = 0.01 + (r1 * 0.01);
        const amplitude1 = 8 + (r1 * 12);    
        
        const noise1 = Math.sin(x * frequency1) * amplitude1;

        // --- MODIFICATION: Start caves closer to the surface (12 -> 8) ---
        const minDepthBelowSurface = 8; 
        const maxDepthBelowSurface = 30; 
        
        let entryDepth = surfaceY + minDepthBelowSurface + noise1;
        
        return Math.round(Math.min(
            surfaceY + maxDepthBelowSurface, 
            Math.max(surfaceY + minDepthBelowSurface, entryDepth)
        ));
    }

    /**
     * Uses 1D noise to calculate the depth (Y-coordinate) where the cave system essentially ends (The Cave Bottom).
     */
    function getCaveBottomY(x) {
        // Deterministically generate noise parameters based on the WORLD_SEED
        const r2 = seededRandom(WORLD_SEED, 20);
        const frequency2 = 0.008 + (r2 * 0.012); 
        const amplitude2 = 10 + (r2 * 15);      
        
        const noise2 = Math.sin(x * frequency2) * amplitude2;
        
        const baseBottom = WORLD_HEIGHT_TILES * 0.7; // Fixed base depth for stability
        
        let bottomDepth = baseBottom + noise2;
        return Math.round(Math.min(
            WORLD_HEIGHT_TILES - 5, // Keep a small bedrock layer
            Math.max(WORLD_HEIGHT_TILES * 0.5, bottomDepth)
        ));
    }


    /**
     * Generates 2D noise for cave system carving. Frequencies are increased to produce
     * smaller, choppier pockets (Swiss cheese effect) with a high density.
     */
    function getCarvingNoise(x, y) {
        // Deterministically generate noise parameters based on the WORLD_SEED
        const seedMultiplier = 1000; 
        
        // Octave 1: Medium-scale density/shape (Increased frequency)
        const r4 = seededRandom(WORLD_SEED, 4 * seedMultiplier);
        const freq4 = 0.06 + (r4 * 0.04); 
        const amp4 = 1.0; 
        
        // Octave 2: Fine-scale pockets/jagged edges (Increased frequency)
        const r5 = seededRandom(WORLD_SEED, 5 * seedMultiplier);
        const freq5 = 0.2 + (r5 * 0.3); 
        const amp5 = 0.5; 

        // Combine Octaves for a noise value
        let noise = 0;
        
        // Octave 1
        noise += Math.sin(x * freq4 + y * freq4) * amp4; 
        
        // Octave 2
        noise += Math.sin(x * freq5 * 0.8 + y * freq5 * 1.2) * amp5; 
        
        // Normalize the noise (sum of amplitudes)
        const totalAmplitude = amp4 + amp5;
        
        // Return a value normalized between -1 and 1
        return (noise / totalAmplitude);
    }


    function generateNewWorld() {
        WORLD_SEED = Math.floor(Math.random() * 1000000); 
        console.log("Generating world with Hyper-Porous Caves and Seed:", WORLD_SEED);
        
        const newMap = [];
        const BASE_HEIGHT = Math.floor(WORLD_HEIGHT_TILES * 0.4); 

        // 1. Generate Surface Height Map (surfaceYMap)
        const surfaceYMap = [];
        for (let x = 0; x < WORLD_WIDTH_TILES; x++) {
            let height = getHeightValue(x) + BASE_HEIGHT;
            height = Math.min(WORLD_HEIGHT_TILES - 5, Math.max(BASE_HEIGHT - 10, height));
            surfaceYMap[x] = Math.round(height);
        }

        // 2. Generate Cave Depth Maps (entry and bottom)
        const caveEntryYMap = [];
        const caveBottomYMap = [];
        for (let x = 0; x < WORLD_WIDTH_TILES; x++) {
            caveEntryYMap[x] = getCaveEntryY(x, surfaceYMap[x]);
            caveBottomYMap[x] = getCaveBottomY(x);
        }

        // 3. Populate Solid Tiles (Dirt, Grass, Stone, Ore)
        for (let y = 0; y < WORLD_HEIGHT_TILES; y++) {
            newMap[y] = [];
            for (let x = 0; x < WORLD_WIDTH_TILES; x++) {
                const surface = surfaceYMap[x];
                let blockId = 0;

                if (y < surface) {
                    blockId = 0; // Air
                } else if (y === surface) {
                    blockId = 2; // Grass
                } else {
                    // Underground layers
                    const depthBelowSurface = y - surface; 
                    
                    if (depthBelowSurface < 3) { 
                        blockId = 1; // Dirt
                    } else if (depthBelowSurface < 8) {
                        blockId = (Math.random() < 0.7) ? 3 : 1; // Mix of Stone and Dirt
                    } else { 
                        blockId = 3; // Stone
                        
                        // Ore generation: 3% chance deep underground
                        if (Math.random() < 0.03) {
                             blockId = 4; // Coal Ore
                        }
                    }
                }
                newMap[y][x] = blockId;
            }
        }
        
        // 4. Cave Carving using 2D Noise constrained by 1D Depth Maps
        // --- MODIFICATION: Lowered carving threshold from 0.38 to 0.25 for extreme density ---
        const CAVE_THRESHOLD = 0.25; 
        for (let y = 0; y < WORLD_HEIGHT_TILES; y++) {
            for (let x = 0; x < WORLD_WIDTH_TILES; x++) {
                // Only carve caves in solid, non-surface blocks (ID 1, 3, 4)
                if (newMap[y][x] !== 0 && newMap[y][x] !== 2) { 
                    
                    const entryY = caveEntryYMap[x];
                    const bottomY = caveBottomYMap[x];
                    
                    // Check if the current block (x, y) is within the defined cave band (Entry to Bottom)
                    if (y >= entryY && y <= bottomY) {
                        const carvingNoise = getCarvingNoise(x, y);
                        
                        // Dynamic threshold: Carving gets easier (threshold gets lower) as depth increases
                        const depthRange = bottomY - entryY || 1; 
                        const depthFactor = (y - entryY) / depthRange; // 0 at entry, 1 at bottom
                        // Reduce threshold by up to 10% towards the bottom
                        const dynamicThreshold = CAVE_THRESHOLD * (1 - 0.1 * depthFactor); 
                        
                        if (carvingNoise > dynamicThreshold) {
                            newMap[y][x] = 0; // Carve out to Air
                        }
                    }
                }
            }
        }


        worldMap = newMap;
        
        // Find a safe spawn point (middle of the map, 2 tiles above the surface)
        const spawnX = Math.floor(WORLD_WIDTH_TILES / 2);
        const spawnY = surfaceYMap[spawnX] - 2; 
        
        player.x = spawnX * TILE_SIZE + (TILE_SIZE - player.w) / 2;
        player.y = spawnY * TILE_SIZE;
        
        // Ensure player spawn area is clear
        for(let i = 0; i < player.h / TILE_SIZE + 1; i++) {
             if (newMap[spawnY + i] && newMap[spawnY + i][spawnX] !== undefined) {
                 newMap[spawnY + i][spawnX] = 0;
             }
        }
    }

    async function loadWorld() {
        if (!isAuthReady) {
            generateNewWorld();
            return;
        }
        
        try {
            const docRef = firebase.doc(db, worldPath(userId));
            const docSnap = await firebase.getDoc(docRef);

            if (docSnap.exists() && docSnap.data().mapData) {
                const data = docSnap.data();
                worldMap = JSON.parse(data.mapData); 
                WORLD_SEED = data.worldSeed || 0; 
                player.x = data.playerX || player.x;
                player.y = data.playerY || player.y;
                player.inventory = data.inventory || player.inventory;
                player.selectedSlot = data.selectedSlot || player.selectedSlot;
                console.log("World loaded successfully with Seed:", WORLD_SEED);
            } else {
                console.log("No world found, generating new one.");
                generateNewWorld();
            }
        } catch (error) {
            console.error("Error loading world:", error);
            generateNewWorld(); // Fallback
        }
    }
    
    async function saveWorld() {
        if (!isAuthReady || !userId) return;

        try {
            const docRef = firebase.doc(db, worldPath(userId));
            const mapDataString = JSON.stringify(worldMap);

            await firebase.setDoc(docRef, {
                mapData: mapDataString,
                worldSeed: WORLD_SEED, 
                playerX: player.x,
                playerY: player.y,
                inventory: player.inventory,
                selectedSlot: player.selectedSlot,
                timestamp: Date.now()
            });
            console.log("World saved successfully!");
        } catch (error) {
            console.error("Error saving world:", error);
        }
    }


    // --- Physics and Player Logic (Cleaned: No Water/Buoyancy) ---

    function isTileSolid(tileX, tileY) {
        if (tileX >= 0 && tileX < WORLD_WIDTH_TILES && tileY >= 0 && tileY < WORLD_HEIGHT_TILES) {
            // Only blocks with ID > 0 are considered solid for collision
            const blockId = worldMap[tileY][tileX];
            return blockId > 0;
        }
        return false; 
    }
    
    // Checks if the given AABB (x, y, w, h) overlaps with any solid tile.
    function checkCollision(x, y, w, h) {
        const startX = Math.floor(x / TILE_SIZE);
        const endX = Math.ceil((x + w) / TILE_SIZE) - 1;
        const startY = Math.floor(y / TILE_SIZE);
        const endY = Math.ceil((y + h) / TILE_SIZE) - 1;

        for (let tileY = startY; tileY <= endY; tileY++) {
            for (let tileX = startX; tileX <= endX; tileX++) {
                if (isTileSolid(tileX, tileY)) { // Corrected parameter to isTileSolid
                    return { x: tileX, y: tileY };
                }
            }
        }
        return false;
    }
    
    function isPlayerOnGroundCheck() {
        // Check for collision 1 pixel below player
        return !!checkCollision(player.x, player.y + 1, player.w, player.h);
    }

    function updatePlayer() {
        
        // Apply damping
        if (!keys['a'] && !keys['d']) {
            player.velX *= 0.8;
            if (Math.abs(player.velX) < 0.5) player.velX = 0;
        }

        if (keys['a']) player.velX = -player.speed;
        if (keys['d']) player.velX = player.speed;
        
        player.velX = Math.min(Math.max(player.velX, -player.speed * 2), player.speed * 2);
        
        // Gravity
        player.velY += GRAVITY;
        player.velY = Math.min(player.velY, TILE_SIZE * 2); // Clamp max fall speed
        
        const canJump = isPlayerOnGroundCheck(); 
        
        // Jump check 
        if (keys[' '] && canJump) {
            player.velY = -player.jumpPower;
        }
        
        // 1. X-AXIS MOVEMENT AND COLLISION RESOLUTION
        player.x += player.velX;
        let collisionX = checkCollision(player.x, player.y, player.w, player.h);

        if (collisionX) {
            const tileX = collisionX.x;
            
            if (player.velX > 0) { 
                player.x = tileX * TILE_SIZE - player.w - 0.1; 
            } else if (player.velX < 0) { 
                player.x = (tileX + 1) * TILE_SIZE + 0.1;
            }
            player.velX = 0;
        }

        // 2. Y-AXIS MOVEMENT AND COLLISION RESOLUTION (Gravity & Jump)
        if (player.velY !== 0) {
            player.onGround = false; 
        }

        player.y += player.velY;
        let collisionY = checkCollision(player.x, player.y, player.w, player.h);

        if (collisionY) {
            const tileY = collisionY.y;
            
            if (player.velY > 0) { // Moving Down (Landing)
                player.y = tileY * TILE_SIZE - player.h - 0.1; 
                player.onGround = true; 
                player.velY = 0;
            } else if (player.velY < 0) { // Moving Up (Hitting Head)
                player.y = (tileY + 1) * TILE_SIZE + 0.1;
                player.velY = 0;
            }
        }
        
        // Clamp player within world bounds
        player.x = Math.max(0, Math.min(player.x, WORLD_WIDTH_TILES * TILE_SIZE - player.w));
        player.y = Math.max(0, Math.min(player.y, WORLD_HEIGHT_TILES * TILE_SIZE - player.h));
    }
    
    // --- Interaction Logic ---

    function getMouseTile() {
        const worldMouseX = mouse.x + camera.offsetX;
        const worldMouseY = mouse.y + camera.offsetY;
        
        const tileX = Math.floor(worldMouseX / TILE_SIZE);
        const tileY = Math.floor(worldMouseY / TILE_SIZE);
        return { x: tileX, y: tileY };
    }
    
    function isMouseWithinReach(tileX, tileY) {
        const playerCenterTileX = Math.floor((player.x + player.w / 2) / TILE_SIZE);
        const playerCenterTileY = Math.floor((player.y + player.h / 2) / TILE_SIZE);

        const dx = Math.abs(tileX - playerCenterTileX);
        const dy = Math.abs(tileY - playerCenterTileY);
        
        return dx <= MAX_REACH_DISTANCE && dy <= MAX_REACH_DISTANCE;
    }

    function handleMining(tileX, tileY) {
        if (!isMouseWithinReach(tileX, tileY)) {
            player.miningBlock = null;
            player.miningTimer = 0;
            return;
        }

        if (tileY < 0 || tileY >= WORLD_HEIGHT_TILES || tileX < 0 || tileX >= WORLD_WIDTH_TILES) return;

        const blockId = worldMap[tileY][tileX];
        if (blockId > 0 && TILE_TYPES[blockId].minable) {
            
            if (!player.miningBlock || player.miningBlock.x !== tileX || player.miningBlock.y !== tileY) {
                player.miningBlock = { x: tileX, y: tileY, id: blockId };
                player.miningTimer = 0;
            }
            
            player.miningTimer += 1;
            
            const miningTime = 60; 
            
            if (player.miningTimer >= miningTime) {
                const dropId = TILE_TYPES[blockId].drops;
                worldMap[tileY][tileX] = 0; 
                player.inventory[dropId] = (player.inventory[dropId] || 0) + 1;
                
                player.miningBlock = null;
                player.miningTimer = 0;
                
                updateInventoryUI();
                // Save after a significant action like mining
                saveWorld(); 
            }
        } else {
            player.miningBlock = null;
            player.miningTimer = 0;
        }
    }
    
    function handlePlacement(tileX, tileY) {
        if (!isMouseWithinReach(tileX, tileY)) return;
        if (tileY < 0 || tileY >= WORLD_HEIGHT_TILES || tileX < 0 || tileX >= WORLD_WIDTH_TILES) return;

        const currentBlock = worldMap[tileY][tileX];
        const itemToPlace = player.selectedSlot;
        
        // Cannot place blocks on top of other solid blocks
        if (currentBlock !== 0) return; 
        
        // Cannot place blocks where the player is standing
        // Use a more specific check than just "checkCollision" to avoid recursion/misinterpretation
        const playerTileX = Math.floor(player.x / TILE_SIZE);
        const playerTileY = Math.floor(player.y / TILE_SIZE);
        
        if (tileX === playerTileX && (tileY === playerTileY || tileY === playerTileY + 1)) return;


        if (player.inventory[itemToPlace] > 0 && TILE_TYPES[itemToPlace].minable) { // Re-using minable property for placable items
            worldMap[tileY][tileX] = itemToPlace;
            player.inventory[itemToPlace] -= 1;
            
            if (player.inventory[itemToPlace] <= 0) {
                delete player.inventory[itemToPlace];
                // Update selected slot if the current item ran out
                const items = Object.keys(player.inventory).map(Number).sort((a, b) => a - b);
                player.selectedSlot = items.length > 0 ? items[0] : 0;
            }
            
            updateInventoryUI();
            saveWorld();
        }
    }

    // --- Rendering ---

    function updateCamera() {
        const targetX = player.x - (VIEWPORT_WIDTH_TILES * TILE_SIZE) / 2 + player.w / 2;
        const targetY = player.y - (VIEWPORT_HEIGHT_TILES * TILE_SIZE) / 2 + player.h / 2;
        
        // Clamp camera to world boundaries
        let maxX = WORLD_WIDTH_TILES * TILE_SIZE - (VIEWPORT_WIDTH_TILES * TILE_SIZE);
        let maxY = WORLD_HEIGHT_TILES * TILE_SIZE - (VIEWPORT_HEIGHT_TILES * TILE_SIZE);

        camera.offsetX = Math.max(0, Math.min(targetX, maxX));
        camera.offsetY = Math.max(0, Math.min(targetY, maxY));
    }


    function drawWorld() {
        // Calculate which tiles are visible
        const startTileX = Math.floor(camera.offsetX / TILE_SIZE);
        const endTileX = Math.ceil((camera.offsetX + canvas.width) / TILE_SIZE);
        const startTileY = Math.floor(camera.offsetY / TILE_SIZE);
        const endTileY = Math.ceil((camera.offsetY + canvas.height) / TILE_SIZE);

        for (let y = startTileY; y < endTileY; y++) {
            for (let x = startTileX; x < endTileX; x++) {
                // Ensure tiles are within world bounds
                if (x < 0 || x >= WORLD_WIDTH_TILES || y < 0 || y >= WORLD_HEIGHT_TILES) continue;

                const blockId = worldMap[y][x];
                
                if (blockId > 0) {
                    const type = TILE_TYPES[blockId];
                    ctx.fillStyle = type.color;
                    
                    // Subtract camera offset for rendering position
                    const drawX = x * TILE_SIZE - camera.offsetX;
                    const drawY = y * TILE_SIZE - camera.offsetY;
                    
                    ctx.fillRect(drawX, drawY, TILE_SIZE, TILE_SIZE);
                    
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
                    ctx.strokeRect(drawX, drawY, TILE_SIZE, TILE_SIZE);
                    
                    // Special rendering for Grass 
                    if (blockId === 2) {
                        ctx.fillStyle = TILE_TYPES[1].color; 
                        ctx.fillRect(drawX, drawY + TILE_SIZE / 4, TILE_SIZE, TILE_SIZE * 3 / 4);
                        ctx.fillStyle = TILE_TYPES[2].color; 
                        ctx.fillRect(drawX, drawY, TILE_SIZE, TILE_SIZE / 4);
                    } 
                }
            }
        }
    }

    function drawPlayer() {
        // Player is drawn relative to the camera offset
        const drawX = player.x - camera.offsetX;
        const drawY = player.y - camera.offsetY;

        ctx.fillStyle = '#fca311'; 
        ctx.fillRect(drawX, drawY, player.w, player.h);
        
        ctx.fillStyle = 'black';
        const eyeX = drawX + (player.velX < 0 ? 3 : (player.velX > 0 ? player.w - 8 : player.w / 2 - 4));
        ctx.fillRect(eyeX, drawY + 8, 5, 5); 
    }
    
    function drawMiningProgress() {
        if (player.miningBlock) {
            const { x: tileX, y: tileY } = player.miningBlock;
            const miningTime = 60;
            const progress = player.miningTimer / miningTime;
            
            if (progress > 0) {
                // Adjust drawing position by camera offset
                const drawX = tileX * TILE_SIZE - camera.offsetX;
                const drawY = tileY * TILE_SIZE - camera.offsetY;
                
                ctx.strokeStyle = `rgba(255, 255, 255, ${Math.min(1, progress * 2)})`;
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(drawX + TILE_SIZE/2, drawY + TILE_SIZE/2, (TILE_SIZE / 2) * progress, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                ctx.fillRect(drawX, drawY + TILE_SIZE - 5, TILE_SIZE * progress, 5);
            }
        }
    }
    
    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height); 
        ctx.fillStyle = '#87ceeb'; // Sky blue background
        ctx.fillRect(0, 0, canvas.width, canvas.height); 
        
        updateCamera(); 

        drawWorld();
        drawMiningProgress();
        drawPlayer();
        
        // Highlight the currently targeted tile
        const { x: tileX, y: tileY } = getMouseTile();
        if (isMouseWithinReach(tileX, tileY)) {
            const drawX = tileX * TILE_SIZE - camera.offsetX;
            const drawY = tileY * TILE_SIZE - camera.offsetY;

            ctx.strokeStyle = mouse.leftDown || mouse.rightDown ? 'red' : 'yellow'; 
            ctx.lineWidth = 3;
            ctx.strokeRect(drawX, drawY, TILE_SIZE, TILE_SIZE);
        }
    }

    // --- UI Update ---

    function updateInventoryUI() {
        const bar = document.getElementById('inventory-bar');
        bar.innerHTML = '';
        
        const itemIds = Object.keys(player.inventory).map(Number).sort((a, b) => a - b);
        
        itemIds.forEach((id, index) => {
            const slot = document.createElement('div');
            const itemName = TILE_TYPES[id].name.substring(0, 1);
            const count = player.inventory[id];
            
            slot.className = `inv-slot ${player.selectedSlot === id ? 'selected' : ''}`;
            slot.classList.add(`tile-color-${id}`);
            slot.textContent = itemName;
            slot.setAttribute('data-item-id', id);
            
            const countSpan = document.createElement('span');
            countSpan.className = 'item-count';
            countSpan.textContent = count;
            slot.appendChild(countSpan);
            
            slot.onclick = () => {
                player.selectedSlot = id;
                updateInventoryUI();
            };
            
            bar.appendChild(slot);
        });
        
        if (itemIds.length < 5) {
            for (let i = itemIds.length; i < 5; i++) {
                const slot = document.createElement('div');
                slot.className = 'inv-slot opacity-50';
                slot.textContent = '';
                bar.appendChild(slot);
            }
        }
    }
    
    // --- Event Listeners ---

    function handleKeyDown(e) {
        if (['a', 'd', ' '].includes(e.key.toLowerCase())) {
            e.preventDefault();
        }
        
        keys[e.key.toLowerCase()] = true;
        
        const slotNumber = parseInt(e.key);
        if (slotNumber >= 1 && slotNumber <= Object.keys(player.inventory).length) {
            const itemIds = Object.keys(player.inventory).map(Number).sort((a, b) => a - b);
            if (itemIds.length > slotNumber - 1) {
                 player.selectedSlot = itemIds[slotNumber - 1];
                 updateInventoryUI();
            }
        }
    }

    function handleKeyUp(e) {
        keys[e.key.toLowerCase()] = false;
    }
    
    function handleMouseDown(e) {
        handleMouseMove(e); 
        
        const { x: tileX, y: tileY } = getMouseTile();

        if (e.button === 0) { // Left Click (Mine)
            mouse.leftDown = true;
        } else if (e.button === 2) { // Right Click (Place)
            mouse.rightDown = true;
            handlePlacement(tileX, tileY);
        }
        
        e.preventDefault(); 
    }

    function handleMouseUp(e) {
        if (e.button === 0) {
            mouse.leftDown = false;
        } else if (e.button === 2) {
            mouse.rightDown = false;
        }
        player.miningBlock = null;
        player.miningTimer = 0;
    }

    function handleMouseMove(e) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;

        mouse.x = e.offsetX * scaleX;
        mouse.y = e.offsetY * scaleY;
    }

    canvas.addEventListener('mousemove', handleMouseMove);
    canvas.addEventListener('mousedown', handleMouseDown);
    canvas.addEventListener('mouseup', handleMouseUp);
    document.addEventListener('keydown', handleKeyDown);
    document.addEventListener('keyup', handleKeyUp);
    canvas.addEventListener('contextmenu', e => e.preventDefault()); 

    let lastSave = Date.now();
    const saveInterval = 30000; 

    // --- Game Loop ---
    function gameLoop() {
        updatePlayer();
        
        if (mouse.leftDown) { 
            const { x: tileX, y: tileY } = getMouseTile();
            handleMining(tileX, tileY); 
        }

        draw();
        
        if (Date.now() - lastSave > saveInterval) {
            saveWorld();
            lastSave = Date.now();
        }

        requestAnimationFrame(gameLoop);
    }
    
    // --- Startup ---
    async function initGame() {
        await initializeFirebase();
        await loadWorld();

        // Ensure player is positioned correctly after world loading/generation
        if (player.y === 0) {
             const surfaceLevel = Math.floor(WORLD_HEIGHT_TILES * 0.4); 
             player.x = (WORLD_WIDTH_TILES / 2) * TILE_SIZE - player.w / 2;
             player.y = (surfaceLevel - 2) * TILE_SIZE;
        }

        updateInventoryUI();
        console.log("AetherBound Initialized with Hyper-Porous Caves. Use A/D to move, SPACE to jump, Left Click to Mine, Right Click to Place.");
        gameLoop();
    }

    window.onload = initGame;
</script>

</body>
</html>