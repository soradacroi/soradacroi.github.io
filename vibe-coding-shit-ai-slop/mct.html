<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AetherBound 2D Sandbox (Infinite World & Chunking)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a2e; /* Deep purple background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }
        #game-container {
            width: 100%;
            max-width: 1200px; /* Increased Max width constraint for visual size */
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            background-color: #2c0f4f; /* Slightly lighter purple for container */
        }
        #game-canvas {
            /* This ensures the canvas respects its fixed internal size but scales visually */
            display: block; 
            width: 100%; /* Make it fill the container's max-width */
            height: auto;
            background-color: #87ceeb; /* Sky blue */
            border-bottom: 4px solid #38bdf8;
            cursor: crosshair;
            /* Canvas size is now fixed by script based on viewport, not world size */
        }
        #ui-panel {
            padding: 12px 20px;
            background-color: #2c0f4f;
            color: #ffffff;
            border-top: 2px solid #38bdf8;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #inventory-bar {
            display: flex;
            gap: 12px;
        }
        .inv-slot {
            width: 64px; /* INCREASED */
            height: 64px; /* INCREASED */
            background-color: #4a148c;
            border: 2px solid #5d209d;
            border-radius: 6px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 16px; /* INCREASED */
            cursor: pointer;
            transition: all 0.1s ease;
            position: relative;
        }
        .inv-slot.selected {
            border-color: #fca311;
            box-shadow: 0 0 10px #fca311;
            transform: scale(1.05);
        }
        .item-count {
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 12px; /* INCREASED */
            background: rgba(0, 0, 0, 0.7);
            padding: 1px 3px;
            border-radius: 3px;
        }
        /* Tile Color Definitions (Visual for Inventory) */
        .tile-color-1 { background-color: #7b3f00; } /* Dirt */
        .tile-color-2 { background-color: #468e27; } /* Grass */
        .tile-color-3 { background-color: #808080; } /* Stone */
        .tile-color-4 { background-color: #333333; } /* Coal Ore */
    </style>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        // MODIFIED IMPORTS for Chunk Management (Collections, Queries, Batch Writes)
        import { getFirestore, doc, setDoc, getDoc, collection, query, where, getDocs, writeBatch } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        window.firebase = {
            initializeApp, getAuth, signInAnonymously, signInWithCustomToken, getFirestore, doc, setDoc, getDoc, collection, query, where, getDocs, writeBatch
        };
    </script>
</head>
<body>

<div id="game-container">
    <canvas id="game-canvas"></canvas>
    <div id="ui-panel">
        <div id="status-message" class="text-sm font-semibold text-sky-400">Loading Game...</div>
        <div id="inventory-bar">
            </div>
    </div>
</div>

<script type="module">
    // --- Global Variables (Provided by Canvas Environment) ---
    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
    const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
    const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null; 

    // --- Game Constants (MODIFIED FOR INFINITE WORLD) ---
    const TILE_SIZE = 48; 
    // const WORLD_WIDTH_TILES = 100; // REMOVED - World is now infinite
    const WORLD_HEIGHT_TILES = 60; // World is still finite vertically
    const GRAVITY = 1;
    const MAX_REACH_DISTANCE = 4; 
    
    // --- CHUNK CONSTANTS ---
    const CHUNK_WIDTH_TILES = 16;
    const CHUNKS_TO_KEEP_LOADED = 5; // e.g., Player's chunk, 2 left, 2 right (5 total)

    // --- VIEWPORT CONSTANTS ---
    const VIEWPORT_WIDTH_TILES = 25; // How many tiles wide the screen is
    const VIEWPORT_HEIGHT_TILES = 15; // How many tiles high the screen is

    // --- World Generation Variables ---
    let WORLD_SEED = 0; // Seed for deterministic generation

    // --- Firebase Initialization ---
    let db, auth;
    let userId = null;
    let isAuthReady = false;
    // MODIFICATION: Use a root path for world metadata and a subcollection for chunks
    const worldMetaDataPath = (uid) => `artifacts/${appId}/users/${uid}/game_meta/main_world`;
    const chunkCollectionPath = (uid) => `artifacts/${appId}/users/${uid}/game_chunks`;

    async function initializeFirebase() {
        try {
            if (firebaseConfig) {
                const app = firebase.initializeApp(firebaseConfig);
                db = firebase.getFirestore(app);
                auth = firebase.getAuth(app);

                if (initialAuthToken) {
                    await firebase.signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await firebase.signInAnonymously(auth);
                }
                
                userId = auth.currentUser.uid;
                isAuthReady = true;
                console.log("Firebase initialized. User ID:", userId);
                document.getElementById('status-message').textContent = `User: ${userId.substring(0, 8)}...`;
            } else {
                isAuthReady = true;
                console.warn("Firebase config missing. Running in offline mode.");
                document.getElementById('status-message').textContent = 'Offline Mode';
            }
        } catch (error) {
            console.error("Firebase Initialization Error:", error);
            isAuthReady = true; 
            document.getElementById('status-message').textContent = 'Auth Error';
        }
    }

    // --- Game State ---
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    
    // Canvas size is based on viewport
    canvas.width = VIEWPORT_WIDTH_TILES * TILE_SIZE;
    canvas.height = VIEWPORT_HEIGHT_TILES * TILE_SIZE;

    const TILE_TYPES = {
        0: { name: "Air", color: "transparent", minable: false, inventory_item: false },
        1: { name: "Dirt", color: "#7b3f00", minable: true, drops: 1, inventory_item: false },
        2: { name: "Grass", color: "#468e27", minable: true, drops: 1, inventory_item: false },
        3: { name: "Stone", color: "#808080", minable: true, drops: 3, inventory_item: false },
        4: { name: "Coal Ore", color: "#333333", minable: true, drops: 4, inventory_item: false },
    };
    
    const player = {
        x: canvas.width / 2, // Start at a local position
        y: 0, 
        w: TILE_SIZE * 0.75, 
        h: TILE_SIZE * 1.5,
        velX: 0,
        velY: 0,
        speed: 5,
        jumpPower: 18, 
        onGround: false,
        miningTimer: 0,
        miningBlock: null,
        reach: TILE_SIZE * MAX_REACH_DISTANCE,
        inventory: {
            1: 99, // Dirt
            3: 50, // Stone
            4: 20, // Coal
        },
        selectedSlot: 1 
    };
    
    // --- Camera/Viewport State ---
    let camera = {
        offsetX: 0,
        offsetY: 0
    };

    // --- CHUNK DATA STRUCTURE ---
    // Stores loaded chunks, keyed by chunkX coordinate. 
    // Format: { [chunkX: number]: TileMap[WORLD_HEIGHT_TILES][CHUNK_WIDTH_TILES] }
    let worldChunks = {}; 
    let currentChunkX = 0; // The chunk the player is currently in

    // --- Helper Functions for Tile/Chunk Conversion ---

    /** Converts a world tile X coordinate to its chunk index. */
    function getChunkX(tileX) {
        // Math.floor works for negative coordinates correctly for chunk index: floor(-0.1) = -1
        return Math.floor(tileX / CHUNK_WIDTH_TILES);
    }
    
    /** Converts a world tile X coordinate to its local index within its chunk (0 to CHUNK_WIDTH_TILES - 1). 
     * FIXED: Uses corrected modulus logic to handle negative X coordinates (moving left).
     */
    function getLocalTileX(tileX) {
        // (x % n + n) % n ensures a positive remainder for all x
        return (tileX % CHUNK_WIDTH_TILES + CHUNK_WIDTH_TILES) % CHUNK_WIDTH_TILES;
    }

    /** Gets a block ID from the loaded chunks. Returns 0 (Air) if the chunk is not loaded or outside vertical bounds. */
    function getBlockId(tileX, tileY) {
        const cX = getChunkX(tileX);
        const lX = getLocalTileX(tileX);

        if (tileY < 0 || tileY >= WORLD_HEIGHT_TILES) return 0; // Always Air outside vertical bounds
        
        if (worldChunks[cX]) {
            // Access the chunk array [tileY][localX]
            return worldChunks[cX][tileY][lX];
        }
        return 0; // Unloaded chunks are treated as empty (Air) for simplicity
    }

    /** Sets a block ID in the loaded chunks. */
    function setBlockId(tileX, tileY, id) {
        const cX = getChunkX(tileX);
        const lX = getLocalTileX(tileX);

        if (worldChunks[cX] && tileY >= 0 && tileY < WORLD_HEIGHT_TILES) {
            worldChunks[cX][tileY][lX] = id;
            return true;
        }
        return false;
    }


    let keys = {};
    let mouse = { x: 0, y: 0, leftDown: false, rightDown: false }; 

    // --- World Generation and Data Management (MODIFIED) ---

    function seededRandom(seed, index) {
        let x = (seed * 9301 + 49297) * (index + 1) % 233280;
        return x / 233280;
    }

    function getHeightValue(x) {
        const r1 = seededRandom(WORLD_SEED, 1);
        const frequency1 = 0.005 + (r1 * 0.015);
        const amplitude1 = 10 + (r1 * 10);    

        const r2 = seededRandom(WORLD_SEED, 2);
        const frequency2 = 0.03 + (r2 * 0.07); 
        const amplitude2 = 5 + (r2 * 8);      

        const r3 = seededRandom(WORLD_SEED, 3);
        const frequency3 = 0.1 + (r3 * 0.2);   
        const amplitude3 = 1 + (r3 * 4);      
        
        const noise1 = Math.sin(x * frequency1) * amplitude1;
        const noise2 = Math.sin(x * frequency2) * amplitude2;
        const noise3 = Math.sin(x * frequency3) * amplitude3;

        // Use seeded random for the random component to ensure chunk seams align
        const rChaos = seededRandom(WORLD_SEED, x * 1337);
        const randomComponent = (rChaos - 0.5) * 2; 

        return noise1 + noise2 + noise3 + randomComponent;
    }
    
    function getCaveEntryY(x, surfaceY) {
        const r1 = seededRandom(WORLD_SEED, 10);
        const frequency1 = 0.01 + (r1 * 0.01);
        const amplitude1 = 8 + (r1 * 12);    
        
        const noise1 = Math.sin(x * frequency1) * amplitude1;

        const minDepthBelowSurface = 8; 
        const maxDepthBelowSurface = 30; 
        
        let entryDepth = surfaceY + minDepthBelowSurface + noise1;
        
        return Math.round(Math.min(
            surfaceY + maxDepthBelowSurface, 
            Math.max(surfaceY + minDepthBelowSurface, entryDepth)
        ));
    }

    function getCaveBottomY(x) {
        const r2 = seededRandom(WORLD_SEED, 20);
        const frequency2 = 0.008 + (r2 * 0.012); 
        const amplitude2 = 10 + (r2 * 15);      
        
        const noise2 = Math.sin(x * frequency2) * amplitude2;
        
        const baseBottom = WORLD_HEIGHT_TILES * 0.7; 
        
        let bottomDepth = baseBottom + noise2;
        return Math.round(Math.min(
            WORLD_HEIGHT_TILES - 5, 
            Math.max(WORLD_HEIGHT_TILES * 0.5, bottomDepth)
        ));
    }


    function getCarvingNoise(x, y) {
        const seedMultiplier = 1000; 
        
        const r4 = seededRandom(WORLD_SEED, 4 * seedMultiplier);
        const freq4 = 0.06 + (r4 * 0.04); 
        const amp4 = 1.0; 
        
        const r5 = seededRandom(WORLD_SEED, 5 * seedMultiplier);
        const freq5 = 0.2 + (r5 * 0.3); 
        const amp5 = 0.5; 

        let noise = 0;
        
        noise += Math.sin(x * freq4 + y * freq4) * amp4; 
        noise += Math.sin(x * freq5 * 0.8 + y * freq5 * 1.2) * amp5; 
        
        const totalAmplitude = amp4 + amp5;
        
        return (noise / totalAmplitude);
    }

    /** Generates a single chunk. */
    function generateChunk(chunkX) {
        const newChunk = [];
        const BASE_HEIGHT = Math.floor(WORLD_HEIGHT_TILES * 0.4); 
        const startWorldX = chunkX * CHUNK_WIDTH_TILES;

        // 1. Generate Surface Height Map (surfaceYMap) for this chunk
        const surfaceYMap = [];
        for (let x = startWorldX; x < startWorldX + CHUNK_WIDTH_TILES; x++) {
            let height = getHeightValue(x) + BASE_HEIGHT;
            height = Math.min(WORLD_HEIGHT_TILES - 5, Math.max(BASE_HEIGHT - 10, height));
            // Store the height map by world X coordinate for consistency
            surfaceYMap[x] = Math.round(height); 
        }

        // 2. Generate Cave Depth Maps (entry and bottom) for this chunk
        const caveEntryYMap = [];
        const caveBottomYMap = [];
        for (let x = startWorldX; x < startWorldX + CHUNK_WIDTH_TILES; x++) {
            caveEntryYMap[x] = getCaveEntryY(x, surfaceYMap[x]);
            caveBottomYMap[x] = getCaveBottomY(x);
        }

        // 3. Populate Solid Tiles
        for (let y = 0; y < WORLD_HEIGHT_TILES; y++) {
            newChunk[y] = [];
            for (let localX = 0; localX < CHUNK_WIDTH_TILES; localX++) {
                const x = startWorldX + localX;
                const surface = surfaceYMap[x];
                let blockId = 0;

                if (y < surface) {
                    blockId = 0; // Air
                } else if (y === surface) {
                    blockId = 2; // Grass
                } else {
                    const depthBelowSurface = y - surface; 
                    
                    if (depthBelowSurface < 3) { 
                        blockId = 1; // Dirt
                    } else if (depthBelowSurface < 8) {
                        // Use seeded random for deterministic generation
                        const r = seededRandom(WORLD_SEED, x * y + 5); 
                        blockId = (r < 0.7) ? 3 : 1; // Mix of Stone and Dirt
                    } else { 
                        blockId = 3; // Stone
                        
                        // Ore generation
                        const r = seededRandom(WORLD_SEED, x * y * 7 + 11);
                        if (r < 0.03) {
                             blockId = 4; // Coal Ore
                        }
                    }
                }
                newChunk[y][localX] = blockId;
            }
        }
        
        // 4. Cave Carving
        const CAVE_THRESHOLD = 0.25; 
        for (let y = 0; y < WORLD_HEIGHT_TILES; y++) {
            for (let localX = 0; localX < CHUNK_WIDTH_TILES; localX++) {
                const x = startWorldX + localX;
                
                if (newChunk[y][localX] !== 0 && newChunk[y][localX] !== 2) { 
                    
                    const entryY = caveEntryYMap[x];
                    const bottomY = caveBottomYMap[x];
                    
                    if (y >= entryY && y <= bottomY) {
                        const carvingNoise = getCarvingNoise(x, y);
                        
                        const depthRange = bottomY - entryY || 1; 
                        const depthFactor = (y - entryY) / depthRange;
                        const dynamicThreshold = CAVE_THRESHOLD * (1 - 0.1 * depthFactor); 
                        
                        if (carvingNoise > dynamicThreshold) {
                            newChunk[y][localX] = 0; // Carve out to Air
                        }
                    }
                }
            }
        }

        // Return the average surface height for spawning, based on the center tile of the chunk
        const centerWorldX = startWorldX + Math.floor(CHUNK_WIDTH_TILES / 2);
        return { chunk: newChunk, surfaceY: surfaceYMap[centerWorldX] };
    }
    
    /** Initializes the world, generating a central chunk and positioning the player. */
    function generateInitialWorld() {
        WORLD_SEED = Math.floor(Math.random() * 1000000); 
        console.log("Generating initial chunk (X=0) with Seed:", WORLD_SEED);
        
        // Generate Chunk 0
        const { chunk, surfaceY } = generateChunk(0);
        worldChunks[0] = chunk;
        currentChunkX = 0;
        
        // Find a safe spawn point in the middle of chunk 0
        const spawnWorldX = Math.floor(CHUNK_WIDTH_TILES / 2); // World X tile coordinate
        const spawnY = surfaceY - 2; 
        
        player.x = spawnWorldX * TILE_SIZE + (TILE_SIZE - player.w) / 2;
        player.y = spawnY * TILE_SIZE;
        
        // Ensure player spawn area is clear in the chunk
        for(let i = 0; i < player.h / TILE_SIZE + 1; i++) {
             // We need to check if the row exists before accessing it
             if (worldChunks[0][spawnY + i]) {
                 worldChunks[0][spawnY + i][getLocalTileX(spawnWorldX)] = 0;
             }
        }
        
        // Pre-load neighboring chunks
        loadAndManageChunks(true); // Force a check
    }
    
    /** Checks player position and loads/unloads chunks as needed. */
    async function loadAndManageChunks(force = false) {
        const playerTileX = Math.floor((player.x + player.w / 2) / TILE_SIZE);
        const newChunkX = getChunkX(playerTileX);
        
        if (newChunkX === currentChunkX && !force) return; // Player is still in the same chunk
        
        console.log(`Player moved from chunk ${currentChunkX} to ${newChunkX}.`);
        currentChunkX = newChunkX;

        const chunksToLoad = [];
        // Calculate the range of chunks that should be loaded (e.g., current +/- 2)
        const minChunk = currentChunkX - Math.floor(CHUNKS_TO_KEEP_LOADED / 2);
        const maxChunk = currentChunkX + Math.ceil(CHUNKS_TO_KEEP_LOADED / 2) - 1;

        // 1. Identify necessary chunks to be loaded
        for (let cX = minChunk; cX <= maxChunk; cX++) {
            if (!worldChunks[cX]) {
                chunksToLoad.push(cX);
            }
        }
        
        // 2. Unload far-away chunks
        const chunksToUnload = Object.keys(worldChunks).map(Number).filter(cX => cX < minChunk || cX > maxChunk);
        
        if (chunksToUnload.length > 0) {
            console.log("Saving and Unloading chunks:", chunksToUnload.join(', '));
            await saveChunks(chunksToUnload); // Save before unloading
            chunksToUnload.forEach(cX => delete worldChunks[cX]);
        }

        // 3. Load new chunks from Firebase or generate
        await loadChunks(chunksToLoad);
    }
    
    /** Loads a list of chunks from Firebase. Generates if not found. */
    async function loadChunks(chunkXList) {
        if (chunkXList.length === 0) return;
        
        // Must wait for Firebase auth before trying to load
        if (!isAuthReady || !userId) {
            console.warn("Loading chunks offline. Generating all missing chunks.");
            chunkXList.forEach(cX => {
                const { chunk } = generateChunk(cX);
                worldChunks[cX] = chunk;
            });
            return;
        }

        const chunksCollection = firebase.collection(db, chunkCollectionPath(userId));
        const chunksToGenerate = [];

        for (const cX of chunkXList) {
            const docRef = firebase.doc(chunksCollection, `chunk_${cX}`);
            
            try {
                const docSnap = await firebase.getDoc(docRef);
                if (docSnap.exists() && docSnap.data().mapData) {
                    // Use JSON.parse to convert the stored string back into an array
                    worldChunks[cX] = JSON.parse(docSnap.data().mapData); 
                    console.log(`Loaded chunk ${cX} from Firebase.`);
                } else {
                    chunksToGenerate.push(cX);
                }
            } catch (error) {
                console.warn(`Error loading chunk ${cX}:`, error);
                chunksToGenerate.push(cX); // Generate if load fails
            }
        }
        
        // Generate any chunks not found in the database
        chunksToGenerate.forEach(cX => {
            const { chunk } = generateChunk(cX);
            worldChunks[cX] = chunk;
            console.log(`Generated new chunk ${cX}.`);
        });
        
        // Immediately save newly generated chunks to prevent loss if the app crashes
        if (chunksToGenerate.length > 0) {
             await saveChunks(chunksToGenerate);
        }
    }


    /** Saves a list of chunks to Firebase using a batch write. */
    async function saveChunks(chunkXList) {
        if (!isAuthReady || !userId || chunkXList.length === 0) return;

        try {
            const batch = firebase.writeBatch(db);
            const chunksCollection = firebase.collection(db, chunkCollectionPath(userId));

            chunkXList.forEach(cX => {
                const docRef = firebase.doc(chunksCollection, `chunk_${cX}`);
                const chunkData = worldChunks[cX]; 
                
                if (chunkData) {
                    batch.set(docRef, {
                        // Store the map as a JSON string to avoid Firestore data limits/structure issues
                        mapData: JSON.stringify(chunkData), 
                        chunkX: cX,
                        worldSeed: WORLD_SEED,
                        timestamp: Date.now()
                    });
                }
            });
            
            await batch.commit();
            console.log(`Batch saved ${chunkXList.length} chunks successfully!`);
        } catch (error) {
            console.error("Error saving chunks:", error);
        }
    }


    async function loadWorld() {
        if (!isAuthReady) {
            generateInitialWorld();
            return;
        }
        
        try {
            // 1. Load World Metadata (Seed, Player Position, Inventory)
            const metaDocRef = firebase.doc(db, worldMetaDataPath(userId));
            const metaDocSnap = await firebase.getDoc(metaDocRef);

            if (metaDocSnap.exists()) {
                const data = metaDocSnap.data();
                WORLD_SEED = data.worldSeed || 0; 
                player.x = data.playerX || player.x;
                player.y = data.playerY || player.y;
                player.inventory = data.inventory || player.inventory;
                player.selectedSlot = data.selectedSlot || player.selectedSlot;
                
                // Calculate the chunk the player should start in
                currentChunkX = getChunkX(Math.floor(player.x / TILE_SIZE));
                console.log("World metadata loaded. Seed:", WORLD_SEED, "Starting Chunk:", currentChunkX);

                // 2. Load surrounding chunks (forced check)
                const chunksToLoad = [];
                const minChunk = currentChunkX - Math.floor(CHUNKS_TO_KEEP_LOADED / 2);
                const maxChunk = currentChunkX + Math.ceil(CHUNKS_TO_KEEP_LOADED / 2) - 1;
                for (let cX = minChunk; cX <= maxChunk; cX++) {
                    chunksToLoad.push(cX);
                }
                
                await loadChunks(chunksToLoad); // This handles loading from DB or generating if missing.
                
            } else {
                console.log("No world metadata found, generating new world.");
                generateInitialWorld();
            }
        } catch (error) {
            console.error("Error loading world:", error);
            generateInitialWorld(); // Fallback
        }
    }
    
    async function saveWorld() {
        if (!isAuthReady || !userId) return;

        try {
            // 1. Save all currently loaded chunks
            const loadedChunks = Object.keys(worldChunks).map(Number);
            await saveChunks(loadedChunks); 
            
            // 2. Save World Metadata
            const metaDocRef = firebase.doc(db, worldMetaDataPath(userId));

            await firebase.setDoc(metaDocRef, {
                worldSeed: WORLD_SEED, 
                playerX: player.x,
                playerY: player.y,
                inventory: player.inventory,
                selectedSlot: player.selectedSlot,
                timestamp: Date.now()
            });
            console.log("World metadata saved successfully!");
        } catch (error) {
            console.error("Error saving world:", error);
        }
    }


    // --- Physics and Player Logic (MODIFIED for Chunking) ---

    function isTileSolid(tileX, tileY) {
        const blockId = getBlockId(tileX, tileY);
        // Only blocks with ID > 0 are considered solid for collision
        return blockId > 0;
    }
    
    // Checks if the given AABB (x, y, w, h) overlaps with any solid tile.
    function checkCollision(x, y, w, h) {
        const startX = Math.floor(x / TILE_SIZE);
        const endX = Math.ceil((x + w) / TILE_SIZE) - 1;
        const startY = Math.floor(y / TILE_SIZE);
        const endY = Math.ceil((y + h) / TILE_SIZE) - 1;

        for (let tileY = startY; tileY <= endY; tileY++) {
            for (let tileX = startX; tileX <= endX; tileX++) {
                // Check world boundaries (only Y is bounded now)
                if (tileY < 0 || tileY >= WORLD_HEIGHT_TILES) continue; 
                
                if (isTileSolid(tileX, tileY)) { 
                    return { x: tileX, y: tileY };
                }
            }
        }
        return false;
    }
    
    function isPlayerOnGroundCheck() {
        return !!checkCollision(player.x, player.y + 1, player.w, player.h);
    }

    function updatePlayer() {
        
        // Apply damping
        if (!keys['a'] && !keys['d']) {
            player.velX *= 0.8;
            if (Math.abs(player.velX) < 0.5) player.velX = 0;
        }

        if (keys['a']) player.velX = -player.speed;
        if (keys['d']) player.velX = player.speed;
        
        player.velX = Math.min(Math.max(player.velX, -player.speed * 2), player.speed * 2);
        
        // Gravity
        player.velY += GRAVITY;
        player.velY = Math.min(player.velY, TILE_SIZE * 2); 
        
        const canJump = isPlayerOnGroundCheck(); 
        
        // Jump check 
        if (keys[' '] && canJump) {
            player.velY = -player.jumpPower;
        }
        
        // 1. X-AXIS MOVEMENT AND COLLISION RESOLUTION
        player.x += player.velX;
        let collisionX = checkCollision(player.x, player.y, player.w, player.h);

        if (collisionX) {
            const tileX = collisionX.x;
            
            if (player.velX > 0) { 
                player.x = tileX * TILE_SIZE - player.w - 0.1; 
            } else if (player.velX < 0) { 
                player.x = (tileX + 1) * TILE_SIZE + 0.1;
            }
            player.velX = 0;
        }

        // 2. Y-AXIS MOVEMENT AND COLLISION RESOLUTION (Gravity & Jump)
        if (player.velY !== 0) {
            player.onGround = false; 
        }

        player.y += player.velY;
        let collisionY = checkCollision(player.x, player.y, player.w, player.h);

        if (collisionY) {
            const tileY = collisionY.y;
            
            if (player.velY > 0) { // Moving Down (Landing)
                player.y = tileY * TILE_SIZE - player.h - 0.1; 
                player.onGround = true; 
                player.velY = 0;
            } else if (player.velY < 0) { // Moving Up (Hitting Head)
                player.y = (tileY + 1) * TILE_SIZE + 0.1;
                player.velY = 0;
            }
        }
        
        // Clamp player within world bounds (Only vertical bounds remain)
        // player.x is now unbounded
        player.y = Math.max(0, Math.min(player.y, WORLD_HEIGHT_TILES * TILE_SIZE - player.h));
        
        // Check for chunk loading/unloading
        loadAndManageChunks(); 
    }
    
    // --- Interaction Logic (MODIFIED for Chunking) ---

    function getMouseTile() {
        const worldMouseX = mouse.x + camera.offsetX;
        const worldMouseY = mouse.y + camera.offsetY;
        
        const tileX = Math.floor(worldMouseX / TILE_SIZE);
        const tileY = Math.floor(worldMouseY / TILE_SIZE);
        return { x: tileX, y: tileY };
    }
    
    function isMouseWithinReach(tileX, tileY) {
        const playerCenterTileX = Math.floor((player.x + player.w / 2) / TILE_SIZE);
        const playerCenterTileY = Math.floor((player.y + player.h / 2) / TILE_SIZE);

        const dx = Math.abs(tileX - playerCenterTileX);
        const dy = Math.abs(tileY - playerCenterTileY);
        
        return dx <= MAX_REACH_DISTANCE && dy <= MAX_REACH_DISTANCE;
    }

    function handleMining(tileX, tileY) {
        if (!isMouseWithinReach(tileX, tileY)) {
            player.miningBlock = null;
            player.miningTimer = 0;
            return;
        }

        // Only check vertical boundary. Horizontal is now infinite.
        if (tileY < 0 || tileY >= WORLD_HEIGHT_TILES) return; 

        const blockId = getBlockId(tileX, tileY); // Use chunk-aware getter

        if (blockId > 0 && TILE_TYPES[blockId].minable) {
            
            if (!player.miningBlock || player.miningBlock.x !== tileX || player.miningBlock.y !== tileY) {
                player.miningBlock = { x: tileX, y: tileY, id: blockId };
                player.miningTimer = 0;
            }
            
            player.miningTimer += 1;
            
            const miningTime = 60; 
            
            if (player.miningTimer >= miningTime) {
                const dropId = TILE_TYPES[blockId].drops;
                setBlockId(tileX, tileY, 0); // Use the chunk-aware setter function
                
                player.inventory[dropId] = (player.inventory[dropId] || 0) + 1;
                
                player.miningBlock = null;
                player.miningTimer = 0;
                
                updateInventoryUI();
                // Save after a significant action like mining
                saveWorld(); 
            }
        } else {
            player.miningBlock = null;
            player.miningTimer = 0;
        }
    }
    
    function handlePlacement(tileX, tileY) {
        if (!isMouseWithinReach(tileX, tileY)) return;
        if (tileY < 0 || tileY >= WORLD_HEIGHT_TILES) return; // Vertical bound check

        const currentBlock = getBlockId(tileX, tileY); // Use the chunk-aware getter function
        const itemToPlace = player.selectedSlot;
        
        if (currentBlock !== 0) return; 
        
        // Cannot place blocks where the player is standing
        const playerTileX = Math.floor(player.x / TILE_SIZE);
        const playerTileY = Math.floor(player.y / TILE_SIZE);
        
        if (tileX === playerTileX && (tileY === playerTileY || tileY === playerTileY + 1)) return;


        if (player.inventory[itemToPlace] > 0 && TILE_TYPES[itemToPlace].minable) { 
            setBlockId(tileX, tileY, itemToPlace); // Use the chunk-aware setter function
            player.inventory[itemToPlace] -= 1;
            
            if (player.inventory[itemToPlace] <= 0) {
                delete player.inventory[itemToPlace];
                const items = Object.keys(player.inventory).map(Number).sort((a, b) => a - b);
                player.selectedSlot = items.length > 0 ? items[0] : 0;
            }
            
            updateInventoryUI();
            saveWorld();
        }
    }

    // --- Rendering (MODIFIED for Chunking) ---

    function updateCamera() {
        const targetX = player.x - (VIEWPORT_WIDTH_TILES * TILE_SIZE) / 2 + player.w / 2;
        const targetY = player.y - (VIEWPORT_HEIGHT_TILES * TILE_SIZE) / 2 + player.h / 2;
        
        // The only clamping is vertical now, to WORLD_HEIGHT_TILES. 
        let maxY = WORLD_HEIGHT_TILES * TILE_SIZE - (VIEWPORT_HEIGHT_TILES * TILE_SIZE);

        camera.offsetX = targetX; // Unbounded horizontal offset
        camera.offsetY = Math.max(0, Math.min(targetY, maxY));
    }


    function drawWorld() {
        // Calculate which tiles are visible
        const startTileX = Math.floor(camera.offsetX / TILE_SIZE);
        const endTileX = Math.ceil((camera.offsetX + canvas.width) / TILE_SIZE);
        const startTileY = Math.floor(camera.offsetY / TILE_SIZE);
        const endTileY = Math.ceil((camera.offsetY + canvas.height) / TILE_SIZE);
        
        // Calculate which chunks are visible/needed to iterate over
        const startChunkX = getChunkX(startTileX);
        const endChunkX = getChunkX(endTileX);

        for (let cX = startChunkX; cX <= endChunkX; cX++) {
            const chunk = worldChunks[cX];
            if (!chunk) continue; // Skip if chunk isn't loaded

            const chunkWorldX = cX * CHUNK_WIDTH_TILES;

            for (let y = startTileY; y < endTileY; y++) {
                if (y < 0 || y >= WORLD_HEIGHT_TILES) continue; // Vertical bounds check

                // Iterate over the tiles within the chunk that are on screen
                const chunkStartX = Math.max(startTileX, chunkWorldX);
                const chunkEndX = Math.min(endTileX, chunkWorldX + CHUNK_WIDTH_TILES);
                
                for (let x = chunkStartX; x < chunkEndX; x++) {
                    const localX = getLocalTileX(x);
                    const blockId = chunk[y][localX]; // Get block directly from loaded chunk array
                    
                    if (blockId > 0) {
                        const type = TILE_TYPES[blockId];
                        ctx.fillStyle = type.color;
                        
                        const drawX = x * TILE_SIZE - camera.offsetX;
                        const drawY = y * TILE_SIZE - camera.offsetY;
                        
                        ctx.fillRect(drawX, drawY, TILE_SIZE, TILE_SIZE);
                        
                        ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
                        ctx.strokeRect(drawX, drawY, TILE_SIZE, TILE_SIZE);
                        
                        if (blockId === 2) {
                            ctx.fillStyle = TILE_TYPES[1].color; 
                            ctx.fillRect(drawX, drawY + TILE_SIZE / 4, TILE_SIZE, TILE_SIZE * 3 / 4);
                            ctx.fillStyle = TILE_TYPES[2].color; 
                            ctx.fillRect(drawX, drawY, TILE_SIZE, TILE_SIZE / 4);
                        } 
                    }
                }
            }
        }
    }
    
    function drawPlayer() {
        // Player is drawn relative to the camera offset
        const drawX = player.x - camera.offsetX;
        const drawY = player.y - camera.offsetY;

        ctx.fillStyle = '#fca311'; 
        ctx.fillRect(drawX, drawY, player.w, player.h);
        
        ctx.fillStyle = 'black';
        const eyeX = drawX + (player.velX < 0 ? 3 : (player.velX > 0 ? player.w - 8 : player.w / 2 - 4));
        ctx.fillRect(eyeX, drawY + 8, 5, 5); 
    }
    
    function drawMiningProgress() {
        if (player.miningBlock) {
            const { x: tileX, y: tileY } = player.miningBlock;
            const miningTime = 60;
            const progress = player.miningTimer / miningTime;
            
            if (progress > 0) {
                // Adjust drawing position by camera offset
                const drawX = tileX * TILE_SIZE - camera.offsetX;
                const drawY = tileY * TILE_SIZE - camera.offsetY;
                
                ctx.strokeStyle = `rgba(255, 255, 255, ${Math.min(1, progress * 2)})`;
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(drawX + TILE_SIZE/2, drawY + TILE_SIZE/2, (TILE_SIZE / 2) * progress, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                ctx.fillRect(drawX, drawY + TILE_SIZE - 5, TILE_SIZE * progress, 5);
            }
        }
    }
    
    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height); 
        ctx.fillStyle = '#87ceeb'; // Sky blue background
        ctx.fillRect(0, 0, canvas.width, canvas.height); 
        
        updateCamera(); 

        drawWorld();
        drawMiningProgress();
        drawPlayer();
        
        // Highlight the currently targeted tile
        const { x: tileX, y: tileY } = getMouseTile();
        if (isMouseWithinReach(tileX, tileY)) {
            const drawX = tileX * TILE_SIZE - camera.offsetX;
            const drawY = tileY * TILE_SIZE - camera.offsetY;

            ctx.strokeStyle = mouse.leftDown || mouse.rightDown ? 'red' : 'yellow'; 
            ctx.lineWidth = 3;
            ctx.strokeRect(drawX, drawY, TILE_SIZE, TILE_SIZE);
        }
    }

    // --- UI Update ---

    function updateInventoryUI() {
        const bar = document.getElementById('inventory-bar');
        bar.innerHTML = '';
        
        const itemIds = Object.keys(player.inventory).map(Number).sort((a, b) => a - b);
        
        itemIds.forEach((id, index) => {
            const slot = document.createElement('div');
            const itemName = TILE_TYPES[id].name.substring(0, 1);
            const count = player.inventory[id];
            
            slot.className = `inv-slot ${player.selectedSlot === id ? 'selected' : ''}`;
            slot.classList.add(`tile-color-${id}`);
            slot.textContent = itemName;
            slot.setAttribute('data-item-id', id);
            
            const countSpan = document.createElement('span');
            countSpan.className = 'item-count';
            countSpan.textContent = count;
            slot.appendChild(countSpan);
            
            slot.onclick = () => {
                player.selectedSlot = id;
                updateInventoryUI();
            };
            
            bar.appendChild(slot);
        });
        
        if (itemIds.length < 5) {
            for (let i = itemIds.length; i < 5; i++) {
                const slot = document.createElement('div');
                slot.className = 'inv-slot opacity-50';
                slot.textContent = '';
                bar.appendChild(slot);
            }
        }
    }
    
    // --- Event Listeners ---

    function handleKeyDown(e) {
        if (['a', 'd', ' '].includes(e.key.toLowerCase())) {
            e.preventDefault();
        }
        
        keys[e.key.toLowerCase()] = true;
        
        const slotNumber = parseInt(e.key);
        if (slotNumber >= 1 && slotNumber <= Object.keys(player.inventory).length) {
            const itemIds = Object.keys(player.inventory).map(Number).sort((a, b) => a - b);
            if (itemIds.length > slotNumber - 1) {
                 player.selectedSlot = itemIds[slotNumber - 1];
                 updateInventoryUI();
            }
        }
    }

    function handleKeyUp(e) {
        keys[e.key.toLowerCase()] = false;
    }
    
    function handleMouseDown(e) {
        handleMouseMove(e); 
        
        const { x: tileX, y: tileY } = getMouseTile();

        if (e.button === 0) { // Left Click (Mine)
            mouse.leftDown = true;
        } else if (e.button === 2) { // Right Click (Place)
            mouse.rightDown = true;
            handlePlacement(tileX, tileY);
        }
        
        e.preventDefault(); 
    }

    function handleMouseUp(e) {
        if (e.button === 0) {
            mouse.leftDown = false;
        } else if (e.button === 2) {
            mouse.rightDown = false;
        }
        player.miningBlock = null;
        player.miningTimer = 0;
    }

    function handleMouseMove(e) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;

        mouse.x = e.offsetX * scaleX;
        mouse.y = e.offsetY * scaleY;
    }

    canvas.addEventListener('mousemove', handleMouseMove);
    canvas.addEventListener('mousedown', handleMouseDown);
    canvas.addEventListener('mouseup', handleMouseUp);
    document.addEventListener('keydown', handleKeyDown);
    document.addEventListener('keyup', handleKeyUp);
    canvas.addEventListener('contextmenu', e => e.preventDefault()); 

    let lastSave = Date.now();
    const saveInterval = 30000; 

    // --- Game Loop ---
    function gameLoop() {
        updatePlayer();
        
        if (mouse.leftDown) { 
            const { x: tileX, y: tileY } = getMouseTile();
            handleMining(tileX, tileY); 
        }

        draw();
        
        if (Date.now() - lastSave > saveInterval) {
            saveWorld();
            lastSave = Date.now();
        }

        requestAnimationFrame(gameLoop);
    }
    
    // --- Startup ---
    async function initGame() {
        await initializeFirebase();
        await loadWorld();

        // Fallback for player position if not loaded or on initial generation
        if (player.y === 0) {
             const surfaceLevel = Math.floor(WORLD_HEIGHT_TILES * 0.4); 
             // Spawn in the middle of chunk 0
             player.x = (CHUNK_WIDTH_TILES / 2) * TILE_SIZE - player.w / 2; 
             player.y = (surfaceLevel - 2) * TILE_SIZE;
        }

        updateInventoryUI();
        console.log("AetherBound Initialized with INFINITE World. Use A/D to move, SPACE to jump, Left Click to Mine, Right Click to Place.");
        gameLoop();
    }

    window.onload = initGame;
</script>

</body>
</html>