<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AetherBound 2D Sandbox (Crafting & Improved Trees)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-auth-compat.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a2e; /* Deep purple background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            user-select: none;
        }
        #game-container {
            width: 100%;
            max-width: 1200px; 
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            background-color: #2c0f4f; /* Slightly lighter purple for container */
        }
        #game-canvas {
            background-color: #000;
            display: block;
            border-bottom: 4px solid #fca311; 
        }
        #ui-overlay {
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #ffffff;
            background-color: #1a1a2e;
        }
        #inventory-bar {
            display: flex;
            gap: 8px;
        }
        .inv-slot {
            width: 48px;
            height: 48px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: 700;
            color: #1a1a2e;
            cursor: pointer;
            position: relative;
            transition: transform 0.1s, box-shadow 0.1s;
            box-shadow: 0 4px #0f0f18;
            border: 3px solid transparent;
        }
        .inv-slot:active {
            transform: translateY(2px);
            box-shadow: 0 2px #0f0f18;
        }
        .inv-slot.selected {
            border-color: #fca311;
            box-shadow: 0 0 15px rgba(252, 163, 17, 0.7);
            transform: scale(1.05);
        }
        .item-count {
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 0.7rem;
            font-weight: 400;
            color: #ffffff;
            background: rgba(0, 0, 0, 0.6);
            padding: 0 4px;
            border-radius: 3px;
        }
        
        /* Tile Color Definitions (Visual for Inventory) */
        .tile-color-1 { background-color: #7b3f00; } /* Dirt */
        .tile-color-2 { background-color: #468e27; } /* Grass */
        .tile-color-3 { background-color: #808080; } /* Stone */
        .tile-color-4 { background-color: #333333; } /* Coal Ore */
        .tile-color-5 { background-color: #5d3e1c; } /* Log */
        .tile-color-6 { background-color: #228b22; } /* Leaves */
        .tile-color-7 { background-color: #a0522d; } /* NEW: Plank */
        .tile-color-8 { background-color: #8b4513; } /* NEW: Workbench */
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <div id="ui-overlay">
            <div id="status-message" class="text-sm text-gray-400">Loading...</div>
            <div id="inventory-bar">
                <!-- Inventory slots go here -->
            </div>
            <div class="text-sm text-yellow-400">C: Craft | RClick: Place</div>
        </div>
    </div>

    <script type="module">
    // --- Global Variables (Provided by Canvas Environment) ---
    // NOTE: These variables are automatically injected by the environment.
    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
    const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
    const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null; 

    // --- Game Constants ---
    const TILE_SIZE = 48; 
    const WORLD_HEIGHT_TILES = 60; // Max height remains fixed
    const GRAVITY = 1;
    const MAX_REACH_DISTANCE = 4; 
    
    // --- CHUNK CONSTANTS --- 
    const CHUNK_SIZE = 16; // 16x16 tiles per chunk
    
    // --- VIEWPORT CONSTANTS ---
    const VIEWPORT_WIDTH_TILES = 25; // How many tiles wide the screen is
    const VIEWPORT_HEIGHT_TILES = 15; // How many tiles high the screen is

    // --- World Generation Variables ---
    let WORLD_SEED = 0; // Seed for deterministic generation

    // --- Firebase Initialization ---
    let db, auth;
    let userId = null;
    let isAuthReady = false;
    const worldPath = (uid) => `artifacts/${appId}/users/${uid}/game_worlds/main_world_chunked`; 

    async function initializeFirebase() {
        try {
            if (firebaseConfig) {
                const app = firebase.initializeApp(firebaseConfig);
                db = firebase.firestore();
                auth = firebase.auth();
                firebase.firestore.setLogLevel('debug');

                if (initialAuthToken) {
                    await auth.signInWithCustomToken(initialAuthToken);
                } else {
                    await auth.signInAnonymously();
                }
                
                auth.onAuthStateChanged(user => {
                    if (user) {
                        userId = user.uid;
                        isAuthReady = true;
                        console.log("Firebase initialized. User ID:", userId);
                        document.getElementById('status-message').textContent = `User: ${userId.substring(0, 8)}...`;
                        loadWorld(); // Load the world only after authentication is complete
                    }
                });

            } else {
                isAuthReady = true;
                console.warn("Firebase config missing. Running in offline mode.");
                document.getElementById('status-message').textContent = 'Offline Mode';
                loadWorld(); // Load world immediately in offline mode
            }
        } catch (error) {
            console.error("Firebase Initialization Error:", error);
            isAuthReady = true; 
            document.getElementById('status-message').textContent = 'Auth Error';
            loadWorld(); // Load world immediately on auth error
        }
    }

    // --- Game State ---
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    
    // Canvas size is based on viewport
    canvas.width = VIEWPORT_WIDTH_TILES * TILE_SIZE;
    canvas.height = VIEWPORT_HEIGHT_TILES * TILE_SIZE;

    // --- TILE TYPES (New items added) ---
    const TILE_TYPES = {
        0: { name: "Air", color: "transparent", minable: false, inventory_item: false, is_solid: false },
        1: { name: "Dirt", color: "#7b3f00", minable: true, drops: 1, inventory_item: true, is_solid: true }, 
        2: { name: "Grass", color: "#468e27", minable: true, drops: 1, inventory_item: false, is_solid: true },
        3: { name: "Stone", color: "#808080", minable: true, drops: 3, inventory_item: true, is_solid: true },
        4: { name: "Coal Ore", color: "#333333", minable: true, drops: 4, inventory_item: true, is_solid: true },
        5: { name: "Log", color: "#5d3e1c", minable: true, drops: 5, inventory_item: true, is_solid: true }, 
        6: { name: "Leaves", color: "#228b22", minable: true, drops: 6, inventory_item: true, is_solid: true }, 
        7: { name: "Plank", color: "#a0522d", minable: true, drops: 7, inventory_item: true, is_solid: true }, // NEW: Plank
        8: { name: "Workbench", color: "#8b4513", minable: true, drops: 8, inventory_item: true, is_solid: true }, // NEW: Workbench
    };
    
    // --- CRAFTING RECIPES ---
    // Format: { id: resultId, name: recipeName, cost: [{ id: costId, amount: costAmount }], resultAmount: amount }
    const CRAFTING_RECIPES = [
        { 
            id: 7, // Plank
            name: "Plank x4", 
            cost: [{ id: 5, amount: 1 }], // 1 Log
            resultAmount: 4,
            workbenchRequired: false
        },
        { 
            id: 8, // Workbench
            name: "Workbench", 
            cost: [{ id: 7, amount: 4 }], // 4 Planks
            resultAmount: 1,
            workbenchRequired: true
        },
    ];
    
    const player = {
        x: canvas.width / 2, 
        y: 0, 
        w: TILE_SIZE * 0.75, 
        h: TILE_SIZE * 1.5,
        velX: 0,
        velY: 0,
        speed: 5,
        jumpPower: 18, 
        onGround: false,
        miningTimer: 0,
        miningBlock: null,
        reach: TILE_SIZE * MAX_REACH_DISTANCE,
        inventory: {
            1: 99, // Dirt
            3: 50, // Stone
            4: 20, // Coal
            5: 10, // Log
            6: 0,  // Leaves 
            7: 5,  // Plank (for testing)
        },
        selectedSlot: 1 
    };
    
    // --- Camera/Viewport State ---
    let camera = {
        offsetX: 0,
        offsetY: 0
    };


    let worldChunks = new Map(); 
    let keys = {};
    let mouse = { x: 0, y: 0, leftDown: false, rightDown: false }; 

    // --- World Generation and Data Management ---

    /**
     * A simple, fast pseudo-random number generator (PRNG) based on a seed.
     * Returns a float between 0 (inclusive) and 1 (exclusive).
     * @param {number} seed - The base world seed.
     * @param {number} index - A unique index (e.g., column index) to diversify the random number.
     */
    function seededRandom(seed, index) {
        // Use a composite seed based on world seed and index
        let totalSeed = seed + index * 101; 
        let x = (totalSeed * 9301 + 49297) % 233280;
        return x / 233280;
    }

    // --- 1D Noise Functions (For Surface and Cave Depth) ---
    function getHeightValue(worldX) {
        const r1 = seededRandom(WORLD_SEED, 1);
        const frequency1 = 0.005 + (r1 * 0.015);
        const amplitude1 = 10 + (r1 * 10);    

        const r2 = seededRandom(WORLD_SEED, 2);
        const frequency2 = 0.03 + (r2 * 0.07); 
        const amplitude2 = 5 + (r2 * 8);      

        const r3 = seededRandom(WORLD_SEED, 3);
        const frequency3 = 0.1 + (r3 * 0.2);   
        const amplitude3 = 1 + (r3 * 4);      
        
        const noise1 = Math.sin(worldX * frequency1) * amplitude1;
        const noise2 = Math.sin(worldX * frequency2) * amplitude2;
        const noise3 = Math.sin(worldX * frequency3) * amplitude3;

        const randomComponent = seededRandom(WORLD_SEED, worldX + 100) * 2 - 1; 

        return noise1 + noise2 + noise3 + randomComponent;
    }
    
    function getCaveEntryY(worldX, surfaceY) {
        const r1 = seededRandom(WORLD_SEED, 10);
        const frequency1 = 0.01 + (r1 * 0.01);
        const amplitude1 = 8 + (r1 * 12);    
        
        const noise1 = Math.sin(worldX * frequency1) * amplitude1;

        const minDepthBelowSurface = 8; 
        const maxDepthBelowSurface = 30; 
        
        let entryDepth = surfaceY + minDepthBelowSurface + noise1;
        
        return Math.round(Math.min(
            surfaceY + maxDepthBelowSurface, 
            Math.max(surfaceY + minDepthBelowSurface, entryDepth)
        ));
    }

    function getCaveBottomY(worldX) {
        const r2 = seededRandom(WORLD_SEED, 20);
        const frequency2 = 0.008 + (r2 * 0.012); 
        const amplitude2 = 10 + (r2 * 15);      
        
        const noise2 = Math.sin(worldX * frequency2) * amplitude2;
        
        const baseBottom = WORLD_HEIGHT_TILES * 0.7; 
        
        let bottomDepth = baseBottom + noise2;
        return Math.round(Math.min(
            WORLD_HEIGHT_TILES - 5, 
            Math.max(WORLD_HEIGHT_TILES * 0.5, bottomDepth)
        ));
    }

    /**
     * @param {number} worldX - Absolute X coordinate in tiles.
     * @param {number} worldY - Absolute Y coordinate in tiles.
     */
    function getCarvingNoise(worldX, worldY) {
        const seedMultiplier = 1000; 
        
        const r4 = seededRandom(WORLD_SEED, 4 * seedMultiplier);
        // MODIFIED: Increased base frequency for more detailed, frequent variations (More Frequent)
        const freq4 = 0.1 + (r4 * 0.04); 
        const amp4 = 1.0; 
        
        const r5 = seededRandom(WORLD_SEED, 5 * seedMultiplier);
        // MODIFIED: Increased base frequency for more detailed, frequent variations (More Frequent)
        const freq5 = 0.4 + (r5 * 0.3); 
        const amp5 = 0.5; 

        let noise = 0;
        
        // Octave 1
        noise += Math.sin(worldX * freq4 + worldY * freq4) * amp4; 
        
        // Octave 2
        noise += Math.sin(worldX * freq5 * 0.8 + worldY * freq5 * 1.2) * amp5; 
        
        const totalAmplitude = amp4 + amp5;
        
        return (noise / totalAmplitude);
    }
    
    // --- CHUNK GENERATION ---

    /**
     * Generates a single chunk of the world.
     * @param {number} chunkX - The X coordinate of the chunk (in chunk units).
     */
    function generateChunk(chunkX) {
        if (worldChunks.get(`${chunkX},0`)) return; 

        const chunkMap = [];
        const BASE_HEIGHT = Math.floor(WORLD_HEIGHT_TILES * 0.4); 
        const startWorldX = chunkX * CHUNK_SIZE;

        // 1. Generate Surface Height Map (surfaceYMap) for this chunk
        const surfaceYMap = [];
        for (let x = 0; x < CHUNK_SIZE; x++) {
            const worldX = startWorldX + x;
            let height = getHeightValue(worldX) + BASE_HEIGHT;
            height = Math.min(WORLD_HEIGHT_TILES - 5, Math.max(BASE_HEIGHT - 10, height));
            surfaceYMap[x] = Math.round(height);
        }

        // 2. Generate Cave Depth Maps
        const caveEntryYMap = [];
        const caveBottomYMap = [];
        for (let x = 0; x < CHUNK_SIZE; x++) {
            const worldX = startWorldX + x;
            caveEntryYMap[x] = getCaveEntryY(worldX, surfaceYMap[x]);
            caveBottomYMap[x] = getCaveBottomY(worldX);
        }

        // 3. Populate Solid Tiles (Dirt, Grass, Stone, Ore)
        for (let y = 0; y < WORLD_HEIGHT_TILES; y++) {
            chunkMap[y] = [];
            for (let x = 0; x < CHUNK_SIZE; x++) {
                const surface = surfaceYMap[x];
                let blockId = 0;

                if (y < surface) {
                    blockId = 0; // Air
                } else if (y === surface) {
                    blockId = 2; // Grass
                } else {
                    const depthBelowSurface = y - surface; 
                    
                    if (depthBelowSurface < 3) { 
                        blockId = 1; // Dirt
                    } else if (depthBelowSurface < 8) {
                        const rMix = seededRandom(WORLD_SEED, startWorldX + x + y * WORLD_HEIGHT_TILES + 10000);
                        blockId = (rMix < 0.7) ? 3 : 1; 
                    } else { 
                        blockId = 3; // Stone
                        
                        // Ore generation: 3% chance deep underground
                        if (seededRandom(WORLD_SEED, startWorldX + x + y * WORLD_HEIGHT_TILES) < 0.03) {
                             blockId = 4; // Coal Ore
                        }
                    }
                }
                chunkMap[y][x] = blockId;
            }
        }
        
        // 4. Cave Carving
        // MODIFIED: Increased threshold from 0.25 to 0.45. Higher threshold means only noise peaks create air, making caves smaller.
        const CAVE_THRESHOLD = 0.45; 
        for (let y = 0; y < WORLD_HEIGHT_TILES; y++) {
            for (let x = 0; x < CHUNK_SIZE; x++) {
                const worldX = startWorldX + x;
                
                if (chunkMap[y][x] !== 0 && chunkMap[y][x] !== 2) { 
                    
                    const entryY = caveEntryYMap[x];
                    const bottomY = caveBottomYMap[x];
                    
                    if (y >= entryY && y <= bottomY) {
                        const carvingNoise = getCarvingNoise(worldX, y);
                        
                        const depthRange = bottomY - entryY || 1; 
                        const depthFactor = (y - entryY) / depthRange; 
                        const dynamicThreshold = CAVE_THRESHOLD * (1 - 0.1 * depthFactor); 
                        
                        if (carvingNoise > dynamicThreshold) {
                            chunkMap[y][x] = 0; // Carve out to Air
                        }
                    }
                }
            }
        }
        
        // --- 5. Tree Generation (MODIFIED FOR LESS CLUSTERING) ---
        const TREE_CHANCE = 0.05; 
        const LOG_ID = 5;
        const LEAF_ID = 6;
        
        for (let x = 0; x < CHUNK_SIZE; x++) {
            const worldX = startWorldX + x;
            const surfaceY = surfaceYMap[x];
            
            if (surfaceY > 0 && chunkMap[surfaceY][x] === 2) { 
                
                // Use a dedicated seeded random index for deterministic tree placement
                const rTree = seededRandom(WORLD_SEED, worldX * 999);
                
                if (rTree < TREE_CHANCE) {
                    
                    // Use a new seeded random index for deterministic height
                    const rHeight = seededRandom(WORLD_SEED, worldX * 1001); 
                    const TREE_HEIGHT = 4 + Math.round(rHeight * 3); // 4 to 7 blocks tall
                    
                    // Place the Trunk (Logs)
                    for (let h = 0; h < TREE_HEIGHT; h++) {
                        const logY = surfaceY - 1 - h; 
                        if (logY >= 0) {
                            chunkMap[logY][x] = LOG_ID; 
                        }
                    }

                    // Place the Canopy (Leaves)
                    const peakY = surfaceY - TREE_HEIGHT;
                    
                    // 3x3 simple square canopy centered on the peak log
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            const leafY = peakY + dy;
                            const leafWorldX = worldX + dx;
                            
                            if (leafY >= 0 && leafY < WORLD_HEIGHT_TILES) {
                                
                                const leafChunkX = Math.floor(leafWorldX / CHUNK_SIZE);
                                const leafLocalX = leafWorldX % CHUNK_SIZE;
                                
                                let targetChunkMap = chunkMap;
                                if (leafChunkX !== chunkX) {
                                    targetChunkMap = worldChunks.get(`${leafChunkX},0`);
                                    if (!targetChunkMap) continue; 
                                }

                                if (targetChunkMap && leafLocalX >= 0 && leafLocalX < CHUNK_SIZE) {
                                    if (targetChunkMap[leafY][leafLocalX] === 0) { 
                                        targetChunkMap[leafY][leafLocalX] = LEAF_ID;
                                    }
                                }
                            }
                        }
                    }
                    
                    // A single log on top of the leaves
                    const topLogY = peakY - 1;
                    if (topLogY >= 0) {
                       if (chunkMap[topLogY][x] === 0) {
                           chunkMap[topLogY][x] = LOG_ID;
                       }
                    }
                }
            }
        }

        worldChunks.set(`${chunkX},0`, chunkMap);
        return chunkMap;
    }
    
    // --- CHUNK ACCESSOR FUNCTIONS ---

    function getBlock(worldX, worldY) {
        if (worldY < 0 || worldY >= WORLD_HEIGHT_TILES) return 0; 
        
        const chunkX = Math.floor(worldX / CHUNK_SIZE);
        const localX = worldX % CHUNK_SIZE;
        const chunkKey = `${chunkX},0`;
        
        let chunk = worldChunks.get(chunkKey);
        
        if (!chunk) {
            chunk = generateChunk(chunkX); 
            if (!chunk) return 0; 
        }
        
        return chunk[worldY][localX];
    }
    
    function setBlock(worldX, worldY, blockId) {
        if (worldY < 0 || worldY >= WORLD_HEIGHT_TILES) return;
        
        const chunkX = Math.floor(worldX / CHUNK_SIZE);
        const localX = worldX % CHUNK_SIZE;
        const chunkKey = `${chunkX},0`;
        
        const chunk = worldChunks.get(chunkKey);
        
        if (chunk) {
            chunk[worldY][localX] = blockId;
        } 
    }

    async function initialLoadAndSpawn() {
        WORLD_SEED = Math.floor(Math.random() * 1000000); 
        console.log("Generating initial chunk with Seed:", WORLD_SEED);

        const spawnChunkX = 1000; 
        generateChunk(spawnChunkX); 

        const centerWorldX = spawnChunkX * CHUNK_SIZE + Math.floor(CHUNK_SIZE / 2);
        const BASE_HEIGHT = Math.floor(WORLD_HEIGHT_TILES * 0.4); 
        const surfaceY = Math.round(getHeightValue(centerWorldX) + BASE_HEIGHT);
        
        const spawnX = centerWorldX * TILE_SIZE + (TILE_SIZE - player.w) / 2;
        const spawnY = (surfaceY - 2) * TILE_SIZE; 
        
        player.x = spawnX;
        player.y = spawnY;

        const playerTileX = Math.floor(player.x / TILE_SIZE);
        const playerTileY = Math.floor(player.y / TILE_SIZE);

        for(let i = 0; i < Math.ceil(player.h / TILE_SIZE + 1); i++) {
             setBlock(playerTileX, playerTileY + i, 0);
        }
    }

    async function loadWorld() {
        if (!isAuthReady || !userId) {
            initialLoadAndSpawn();
            return;
        }
        
        try {
            const docRef = db.collection('artifacts').doc(appId).collection('users').doc(userId).collection('game_worlds').doc('main_world_chunked');
            const docSnap = await docRef.get();

            if (docSnap.exists) {
                const data = docSnap.data();
                
                WORLD_SEED = data.worldSeed || Math.floor(Math.random() * 1000000);
                player.x = data.playerX || player.x;
                player.y = data.playerY || player.y;
                // Safely parse inventory if stored as JSON string (not strictly needed for simple objects, but good practice)
                player.inventory = data.inventory || player.inventory;
                player.selectedSlot = data.selectedSlot || player.selectedSlot;
                
                console.log("Player data loaded successfully with Seed:", WORLD_SEED);
                
                const playerChunkX = Math.floor(player.x / TILE_SIZE / CHUNK_SIZE);
                // Load/Generate chunks around the player
                for (let cx = playerChunkX - 2; cx <= playerChunkX + 2; cx++) {
                     generateChunk(cx);
                }

            } else {
                console.log("No world found, generating new one.");
                initialLoadAndSpawn();
                const playerChunkX = Math.floor(player.x / TILE_SIZE / CHUNK_SIZE);
                for (let cx = playerChunkX - 2; cx <= playerChunkX + 2; cx++) {
                     generateChunk(cx);
                }
            }
        } catch (error) {
            console.error("Error loading world:", error);
            initialLoadAndSpawn(); 
        }
    }
    
    async function saveWorld() {
        if (!isAuthReady || !userId) return;

        try {
            const docRef = db.collection('artifacts').doc(appId).collection('users').doc(userId).collection('game_worlds').doc('main_world_chunked');
            
            await docRef.set({
                worldSeed: WORLD_SEED, 
                playerX: player.x,
                playerY: player.y,
                inventory: player.inventory, // Simple object save
                selectedSlot: player.selectedSlot,
                timestamp: firebase.firestore.FieldValue.serverTimestamp()
            });
            console.log("Player state saved successfully!");
        } catch (error) {
            console.error("Error saving world:", error);
        }
    }


    // --- Physics and Player Logic ---

    function isTileSolid(worldX, worldY) {
        if (worldY < 0 || worldY >= WORLD_HEIGHT_TILES) {
            return worldY >= WORLD_HEIGHT_TILES; 
        }
        const blockId = getBlock(worldX, worldY);
        return blockId > 0 && TILE_TYPES[blockId].is_solid;
    }
    
    function checkCollision(x, y, w, h) {
        const startX = Math.floor(x / TILE_SIZE);
        const endX = Math.ceil((x + w) / TILE_SIZE) - 1;
        const startY = Math.floor(y / TILE_SIZE);
        const endY = Math.ceil((y + h) / TILE_SIZE) - 1;

        for (let tileY = startY; tileY <= endY; tileY++) {
            for (let tileX = startX; tileX <= endX; tileX++) {
                if (isTileSolid(tileX, tileY)) { 
                    return { x: tileX, y: tileY };
                }
            }
        }
        return false;
    }
    
    function isPlayerOnGroundCheck() {
        return !!checkCollision(player.x, player.y + 1, player.w, player.h);
    }

    function updatePlayer() {
        
        if (!keys['a'] && !keys['d']) {
            player.velX *= 0.8;
            if (Math.abs(player.velX) < 0.5) player.velX = 0;
        }

        if (keys['a']) player.velX = -player.speed;
        if (keys['d']) player.velX = player.speed;
        
        player.velX = Math.min(Math.max(player.velX, -player.speed * 2), player.speed * 2);
        
        player.velY += GRAVITY;
        player.velY = Math.min(player.velY, TILE_SIZE * 2); 
        
        const canJump = isPlayerOnGroundCheck(); 
        
        if (keys[' '] && canJump) {
            player.velY = -player.jumpPower;
        }
        
        // 1. X-AXIS MOVEMENT AND COLLISION RESOLUTION
        player.x += player.velX;
        let collisionX = checkCollision(player.x, player.y, player.w, player.h);

        if (collisionX) {
            const tileX = collisionX.x;
            
            if (player.velX > 0) { 
                player.x = tileX * TILE_SIZE - player.w - 0.1; 
            } else if (player.velX < 0) { 
                player.x = (tileX + 1) * TILE_SIZE + 0.1;
            }
            player.velX = 0;
        }

        // 2. Y-AXIS MOVEMENT AND COLLISION RESOLUTION
        if (player.velY !== 0) {
            player.onGround = false; 
        }

        player.y += player.velY;
        let collisionY = checkCollision(player.x, player.y, player.w, player.h);

        if (collisionY) {
            const tileY = collisionY.y;
            
            if (player.velY > 0) { 
                player.y = tileY * TILE_SIZE - player.h - 0.1; 
                player.onGround = true; 
                player.velY = 0;
            } else if (player.velY < 0) { 
                player.y = (tileY + 1) * TILE_SIZE + 0.1;
                player.velY = 0;
            }
        }
        
        player.y = Math.max(0, Math.min(player.y, WORLD_HEIGHT_TILES * TILE_SIZE - player.h));
    }
    
    // --- Interaction Logic ---

    function getMouseTile() {
        const worldMouseX = mouse.x + camera.offsetX;
        const worldMouseY = mouse.y + camera.offsetY;
        
        const tileX = Math.floor(worldMouseX / TILE_SIZE);
        const tileY = Math.floor(worldMouseY / TILE_SIZE);
        return { x: tileX, y: tileY };
    }
    
    function isMouseWithinReach(tileX, tileY) {
        const playerCenterTileX = Math.floor((player.x + player.w / 2) / TILE_SIZE);
        const playerCenterTileY = Math.floor((player.y + player.h / 2) / TILE_SIZE);

        const dx = Math.abs(tileX - playerCenterTileX);
        const dy = Math.abs(tileY - playerCenterTileY);
        
        return dx <= MAX_REACH_DISTANCE && dy <= MAX_REACH_DISTANCE;
    }

    function handleMining(tileX, tileY) {
        if (!isMouseWithinReach(tileX, tileY)) {
            player.miningBlock = null;
            player.miningTimer = 0;
            return;
        }

        if (tileY < 0 || tileY >= WORLD_HEIGHT_TILES) return;

        const blockId = getBlock(tileX, tileY);
        if (blockId > 0 && TILE_TYPES[blockId].minable) {
            
            if (!player.miningBlock || player.miningBlock.x !== tileX || player.miningBlock.y !== tileY) {
                player.miningBlock = { x: tileX, y: tileY, id: blockId };
                player.miningTimer = 0;
            }
            
            player.miningTimer += 1;
            
            const miningTime = 60; 
            
            if (player.miningTimer >= miningTime) {
                const dropId = TILE_TYPES[blockId].drops;
                setBlock(tileX, tileY, 0); 
                
                if (dropId > 0) {
                   player.inventory[dropId] = (player.inventory[dropId] || 0) + 1;
                }
                
                player.miningBlock = null;
                player.miningTimer = 0;
                
                updateInventoryUI();
                saveWorld(); 
            }
        } else {
            player.miningBlock = null;
            player.miningTimer = 0;
        }
    }
    
    function handlePlacement(tileX, tileY) {
        if (!isMouseWithinReach(tileX, tileY)) return;
        if (tileY < 0 || tileY >= WORLD_HEIGHT_TILES) return;

        const currentBlock = getBlock(tileX, tileY);
        const itemToPlace = player.selectedSlot;
        
        if (currentBlock !== 0) return; 
        
        const playerTileX = Math.floor(player.x / TILE_SIZE);
        const playerTileY = Math.floor(player.y / TILE_SIZE);
        
        if (tileX === playerTileX && (tileY === playerTileY || tileY === playerTileY + 1)) return;


        if (player.inventory[itemToPlace] > 0 && TILE_TYPES[itemToPlace] && TILE_TYPES[itemToPlace].inventory_item) { 
            setBlock(tileX, tileY, itemToPlace); 
            player.inventory[itemToPlace] -= 1;
            
            if (player.inventory[itemToPlace] <= 0) {
                delete player.inventory[itemToPlace];
                const items = Object.keys(player.inventory).map(Number).sort((a, b) => a - b);
                player.selectedSlot = items.length > 0 ? items[0] : 0;
            }
            
            updateInventoryUI();
            saveWorld();
        }
    }
    
    /**
     * Handles crafting on 'C' press.
     */
    function handleCrafting() {
        const playerTileX = Math.floor((player.x + player.w / 2) / TILE_SIZE);
        const playerTileY = Math.floor((player.y + player.h / 2) / TILE_SIZE);
        
        // 1. Check for a nearby workbench (ID 8)
        let hasWorkbenchNearby = false;
        for(let dx = -1; dx <= 1; dx++) {
            for(let dy = -1; dy <= 1; dy++) {
                if(getBlock(playerTileX + dx, playerTileY + dy) === 8) {
                    hasWorkbenchNearby = true;
                    break;
                }
            }
            if(hasWorkbenchNearby) break;
        }
        
        let crafted = false;
        let message = 'No recipes match your resources.';

        for (const recipe of CRAFTING_RECIPES) {
            
            // Check Workbench requirement
            if (recipe.workbenchRequired && !hasWorkbenchNearby) {
                message = `A Workbench is required to craft ${recipe.name}.`;
                continue; 
            }

            // Check if all costs are met
            let canCraft = true;
            for (const cost of recipe.cost) {
                if ((player.inventory[cost.id] || 0) < cost.amount) {
                    canCraft = false;
                    break;
                }
            }

            if (canCraft) {
                // Consume resources
                for (const cost of recipe.cost) {
                    player.inventory[cost.id] -= cost.amount;
                    if (player.inventory[cost.id] <= 0) {
                         delete player.inventory[cost.id];
                    }
                }
                
                // Add result to inventory
                player.inventory[recipe.id] = (player.inventory[recipe.id] || 0) + recipe.resultAmount;
                
                document.getElementById('status-message').textContent = `Crafted ${recipe.name}!`;
                crafted = true;
                break; 
            }
        }
        
        if (crafted) {
            updateInventoryUI();
            saveWorld();
        } else {
             document.getElementById('status-message').textContent = message;
        }
    }


    // --- Rendering and Chunk Loading/Unloading ---

    function updateCamera() {
        const targetX = player.x - (VIEWPORT_WIDTH_TILES * TILE_SIZE) / 2 + player.w / 2;
        const targetY = player.y - (VIEWPORT_HEIGHT_TILES * TILE_SIZE) / 2 + player.h / 2;
        
        let maxY = WORLD_HEIGHT_TILES * TILE_SIZE - (VIEWPORT_HEIGHT_TILES * TILE_SIZE);

        camera.offsetX = targetX; 
        camera.offsetY = Math.max(0, Math.min(targetY, maxY));
    }
    
    function loadAndUnloadChunks() {
        const cameraTileX = Math.floor(camera.offsetX / TILE_SIZE);
        
        const startChunkX = Math.floor((cameraTileX - CHUNK_SIZE) / CHUNK_SIZE);
        const endChunkX = Math.ceil((cameraTileX + VIEWPORT_WIDTH_TILES + CHUNK_SIZE) / CHUNK_SIZE);

        for (let cx = startChunkX; cx < endChunkX; cx++) {
            if (!worldChunks.get(`${cx},0`)) {
                generateChunk(cx);
            }
        }
        
        for (const key of worldChunks.keys()) {
            const [cx, cy] = key.split(',').map(Number);
            if (cx < startChunkX - 2 || cx > endChunkX + 2) {
                worldChunks.delete(key);
            }
        }
    }


    function drawWorld() {
        const startTileX = Math.floor(camera.offsetX / TILE_SIZE);
        const endTileX = Math.ceil((camera.offsetX + canvas.width) / TILE_SIZE);
        const startTileY = Math.floor(camera.offsetY / TILE_SIZE);
        const endTileY = Math.ceil((camera.offsetY + canvas.height) / TILE_SIZE);

        for (let y = startTileY; y < endTileY; y++) {
            for (let x = startTileX; x < endTileX; x++) {
                if (y < 0 || y >= WORLD_HEIGHT_TILES) continue;

                const blockId = getBlock(x, y); 
                
                if (blockId > 0) {
                    const type = TILE_TYPES[blockId];
                    ctx.fillStyle = type.color;
                    
                    const drawX = x * TILE_SIZE - camera.offsetX;
                    const drawY = y * TILE_SIZE - camera.offsetY;
                    
                    ctx.fillRect(drawX, drawY, TILE_SIZE, TILE_SIZE);
                    
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
                    ctx.strokeRect(drawX, drawY, TILE_SIZE, TILE_SIZE);
                    
                    // Special rendering for Grass 
                    if (blockId === 2) {
                        ctx.fillStyle = TILE_TYPES[1].color; 
                        ctx.fillRect(drawX, drawY + TILE_SIZE / 4, TILE_SIZE, TILE_SIZE * 3 / 4);
                        ctx.fillStyle = TILE_TYPES[2].color; 
                        ctx.fillRect(drawX, drawY, TILE_SIZE, TILE_SIZE / 4);
                    } 
                }
            }
        }
    }

    function drawPlayer() {
        const drawX = player.x - camera.offsetX;
        const drawY = player.y - camera.offsetY;

        ctx.fillStyle = '#fca311'; 
        ctx.fillRect(drawX, drawY, player.w, player.h);
        
        ctx.fillStyle = 'black';
        const eyeX = drawX + (player.velX < 0 ? 3 : (player.velX > 0 ? player.w - 8 : player.w / 2 - 4));
        ctx.fillRect(eyeX, drawY + 8, 5, 5); 
    }
    
    function drawMiningProgress() {
        if (player.miningBlock) {
            const { x: tileX, y: tileY } = player.miningBlock;
            const miningTime = 60;
            const progress = player.miningTimer / miningTime;
            
            if (progress > 0) {
                const drawX = tileX * TILE_SIZE - camera.offsetX;
                const drawY = tileY * TILE_SIZE - camera.offsetY;
                
                ctx.strokeStyle = `rgba(255, 255, 255, ${Math.min(1, progress * 2)})`;
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(drawX + TILE_SIZE/2, drawY + TILE_SIZE/2, (TILE_SIZE / 2) * progress, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                ctx.fillRect(drawX, drawY + TILE_SIZE - 5, TILE_SIZE * progress, 5);
            }
        }
    }
    
    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height); 
        ctx.fillStyle = '#87ceeb'; 
        ctx.fillRect(0, 0, canvas.width, canvas.height); 
        
        updateCamera(); 
        loadAndUnloadChunks(); 

        drawWorld();
        drawMiningProgress();
        drawPlayer();
        
        const { x: tileX, y: tileY } = getMouseTile();
        if (isMouseWithinReach(tileX, tileY)) {
            const drawX = tileX * TILE_SIZE - camera.offsetX;
            const drawY = tileY * TILE_SIZE - camera.offsetY;

            ctx.strokeStyle = mouse.leftDown || mouse.rightDown ? 'red' : 'yellow'; 
            ctx.lineWidth = 3;
            ctx.strokeRect(drawX, drawY, TILE_SIZE, TILE_SIZE);
        }
    }

    // --- UI Update ---

    function updateInventoryUI() {
        const bar = document.getElementById('inventory-bar');
        bar.innerHTML = '';
        
        const tileColors = {
            1: 'tile-color-1', 3: 'tile-color-3', 4: 'tile-color-4', 
            5: 'tile-color-5', 6: 'tile-color-6', 7: 'tile-color-7', 
            8: 'tile-color-8', 
        };
        
        const itemIds = Object.keys(player.inventory)
            .map(Number)
            .filter(id => player.inventory[id] > 0) 
            .sort((a, b) => a - b);
        
        if (!itemIds.includes(player.selectedSlot) && itemIds.length > 0) {
            player.selectedSlot = itemIds[0];
        } else if (itemIds.length === 0) {
            player.selectedSlot = 0; 
        }

        const maxSlots = 5;
        for (let i = 0; i < maxSlots; i++) {
            const id = itemIds[i];
            const slot = document.createElement('div');

            if (id) {
                const itemName = TILE_TYPES[id].name.substring(0, 1);
                const count = player.inventory[id];
                
                slot.className = `inv-slot ${player.selectedSlot === id ? 'selected' : ''}`;
                slot.classList.add(tileColors[id] || 'tile-color-default'); 
                slot.textContent = itemName;
                slot.setAttribute('data-item-id', id);
                
                const countSpan = document.createElement('span');
                countSpan.className = 'item-count';
                countSpan.textContent = count;
                slot.appendChild(countSpan);

                slot.onclick = () => {
                    player.selectedSlot = id;
                    updateInventoryUI();
                };
            } else {
                 slot.className = 'inv-slot opacity-50 bg-gray-600';
            }
            
            bar.appendChild(slot);
        }
    }
    
    // --- Event Listeners ---

    function handleKeyDown(e) {
        if (['a', 'd', ' ', 'c'].includes(e.key.toLowerCase())) {
            e.preventDefault();
        }
        
        keys[e.key.toLowerCase()] = true;
        
        if (e.key.toLowerCase() === 'c') {
             handleCrafting(); 
             return;
        }
        
        const slotNumber = parseInt(e.key);
        if (slotNumber >= 1 && slotNumber <= 9) { 
            const itemIds = Object.keys(player.inventory).map(Number).filter(id => player.inventory[id] > 0).sort((a, b) => a - b);
            
            if (itemIds.length >= slotNumber) {
                 player.selectedSlot = itemIds[slotNumber - 1];
                 updateInventoryUI();
            }
        }
    }

    function handleKeyUp(e) {
        keys[e.key.toLowerCase()] = false;
    }
    
    function handleMouseDown(e) {
        handleMouseMove(e); 
        
        const { x: tileX, y: tileY } = getMouseTile();

        if (e.button === 0) { // Left Click (Mine)
            mouse.leftDown = true;
        } else if (e.button === 2) { // Right Click (Place)
            mouse.rightDown = true;
            handlePlacement(tileX, tileY);
        }
        
        e.preventDefault(); 
    }

    function handleMouseUp(e) {
        if (e.button === 0) {
            mouse.leftDown = false;
        } else if (e.button === 2) {
            mouse.rightDown = false;
        }
        player.miningBlock = null;
        player.miningTimer = 0;
    }

    function handleMouseMove(e) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;

        mouse.x = e.offsetX * scaleX;
        mouse.y = e.offsetY * scaleY;
    }

    canvas.addEventListener('mousemove', handleMouseMove);
    canvas.addEventListener('mousedown', handleMouseDown);
    canvas.addEventListener('mouseup', handleMouseUp);
    document.addEventListener('keydown', handleKeyDown);
    document.addEventListener('keyup', handleKeyUp);
    canvas.addEventListener('contextmenu', e => e.preventDefault()); 

    let lastSave = Date.now();
    const saveInterval = 30000; 

    // --- Game Loop ---
    function gameLoop() {
        updatePlayer();
        
        if (mouse.leftDown) { 
            const { x: tileX, y: tileY } = getMouseTile();
            handleMining(tileX, tileY); 
        }

        draw();
        
        if (Date.now() - lastSave > saveInterval) {
            saveWorld();
            lastSave = Date.now();
        }

        requestAnimationFrame(gameLoop);
    }
    
    // --- Startup ---
    async function initGame() {
        await initializeFirebase();
        updateInventoryUI();
        console.log("AetherBound Initialized. Controls: A/D to move, SPACE to jump, Left Click to Mine, Right Click to Place, C to Craft.");
        gameLoop();
    }

    window.onload = initGame;
</script>
</body>
</html>